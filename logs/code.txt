
Filesystem structure:

.
├── .env
├── App.tsx
├── README.md
├── app.json
├── babel.config.js
├── components.json
├── database
│   └── dev_target_schema.sql
├── eslint.config.js
├── expo-start.js
├── logs
│   ├── code.log
│   ├── dev.log
│   └── structure.txt
├── package.json
├── postcss.config.js
├── src
│   ├── components
│   │   ├── AdvancedFilterModal.tsx
│   │   ├── CategoriesSection.tsx
│   │   ├── CategoryFilter.tsx
│   │   ├── FeaturedPhotoSection.tsx
│   │   ├── FilterDebugger.tsx
│   │   ├── FilterModal.tsx
│   │   ├── GalleryHeader.tsx
│   │   ├── HeaderSection.tsx
│   │   ├── PhotoItem.tsx
│   │   ├── PhotoList.tsx
│   │   ├── SearchBar.tsx
│   │   ├── WelcomeSection.tsx
│   │   └── filters
│   │       ├── DateRangeFilter.tsx
│   │       └── OrganisationFilter.tsx
│   ├── context
│   │   ├── AuthContext.tsx
│   │   ├── CartContext.tsx
│   │   └── FilterContext.tsx
│   ├── hooks
│   │   ├── use-mobile.tsx
│   │   ├── use-toast.ts
│   │   ├── useDebounce.ts
│   │   ├── useNetworkStatus.ts
│   │   ├── usePhotoFilters.ts
│   │   └── useSearch.ts
│   ├── integrations
│   │   └── supabase
│   │       ├── client.ts
│   │       └── types.ts
│   ├── lib
│   │   └── utils.ts
│   ├── screens
│   │   ├── AdminScreen.tsx
│   │   ├── AuthScreen.tsx
│   │   ├── CartScreen.tsx
│   │   ├── GalleryScreen.tsx
│   │   ├── HomeScreen.tsx
│   │   ├── PhotoDetailScreen.tsx
│   │   └── ProfileScreen.tsx
│   ├── services
│   │   ├── authService.js
│   │   ├── cartService.js
│   │   ├── catalogService.ts
│   │   ├── photoService.ts
│   │   ├── supabase.ts
│   │   └── userService.js
│   ├── types
│   │   └── supabase.ts
│   └── utils
│       ├── animations.tsx
│       ├── cache.ts
│       └── imageCache.ts
├── supabase
│   └── config.toml
├── tailwind.config.js
├── tailwind.config.ts
├── tsconfig.app.json
├── tsconfig.json
└── tsconfig.node.json

15 directories, 63 files

The codebase as of 03/04/2025:

===== ./.env =====
EXPO_PUBLIC_SUPABASE_URL=https://tvucfqzldbcghtxddtmq.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR2dWNmcXpsZGJjZ2h0eGRkdG1xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzk5ODk4OTcsImV4cCI6MjA1NTU2NTg5N30.5p5Gq-Q2PPaJfTQKrzVGwh8fGHBd8dM8HYnii1O3sQw
===== ./.expo/devices.json =====
{
  "devices": []
}

===== ./.expo/packager-info.json =====
{
  "expoServerPort": 19000,
  "packagerPort": 19000
}

===== ./.expo/README.md =====
> Why do I have a folder named ".expo" in my project?
The ".expo" folder is created when an Expo project is started using "expo start" command.
> What do the files contain?
- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "settings.json": contains the server configuration that is used to serve the application manifest.
> Should I commit the ".expo" folder?
No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.
Upon project creation, the ".expo" folder is already added to your ".gitignore" file.

===== ./.expo/settings.json =====
{
  "hostType": "lan",
  "lanType": "ip",
  "dev": true,
  "minify": false,
  "urlRandomness": null,
  "https": false,
  "scheme": null
}

===== ./.gitignore =====
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

===== ./app.json =====
{
  "expo": {
    "name": "TrainPixelfolio",
    "slug": "trainpixelfolio",
    "version": "1.0.0",
    "newArchEnabled": true,
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#1A237E"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.blueairblob.trainpixelfolio"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#1A237E"
      },
      "package": "com.blueairblob.trainpixelfolio"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "your-project-id-here"
      }
    },
    "owner": "blueairblob",
    "plugins": [
      "expo-font"
    ]
  }
}

===== ./App.tsx =====
// App.tsx
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { StatusBar } from 'react-native';

// Import screens
import HomeScreen from './src/screens/HomeScreen';
import GalleryScreen from './src/screens/GalleryScreen';
import PhotoDetailScreen from './src/screens/PhotoDetailScreen';
import CartScreen from './src/screens/CartScreen';
import ProfileScreen from './src/screens/ProfileScreen';
import AdminScreen from './src/screens/AdminScreen';
import AuthScreen from './src/screens/AuthScreen';

// Import icons
import { Ionicons } from '@expo/vector-icons';

// Import auth provider
import { AuthProvider, useAuth } from './src/context/AuthContext';

// Create the navigators
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

// Main tab navigator
const TabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;

          if (route.name === 'Home') {
            iconName = focused ? 'home' : 'home-outline';
          } else if (route.name === 'Gallery') {
            iconName = focused ? 'images' : 'images-outline';
          } else if (route.name === 'Cart') {
            iconName = focused ? 'cart' : 'cart-outline';
          } else if (route.name === 'Profile') {
            iconName = focused ? 'person' : 'person-outline';
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#4f46e5',
        tabBarInactiveTintColor: 'gray',
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Gallery" component={GalleryScreen} />
      <Tab.Screen name="Cart" component={CartScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
};

// Root navigator with auth check
const RootNavigator = () => {
  const { isAuthenticated, isLoading } = useAuth();
  
  // Show nothing while checking authentication status
  if (isLoading) {
    return null;
  }

  return (
    <Stack.Navigator>
      {!isAuthenticated ? (
        <Stack.Screen 
          name="Auth" 
          component={AuthScreen} 
          options={{ headerShown: false }}
        />
      ) : (
        <>
          <Stack.Screen 
            name="Main" 
            component={TabNavigator} 
            options={{ headerShown: false }}
          />
          <Stack.Screen name="PhotoDetail" component={PhotoDetailScreen} />
          <Stack.Screen name="Admin" component={AdminScreen} />
        </>
      )}
    </Stack.Navigator>
  );
};

// App component with auth provider
const App = () => {
  console.log("Running App.tsx");

  return (
    <SafeAreaProvider>
      <StatusBar barStyle="dark-content" />
      <AuthProvider>
        <NavigationContainer>
          <RootNavigator />
        </NavigationContainer>
      </AuthProvider>
    </SafeAreaProvider>
  );
};

export default App;

===== ./babel.config.js =====

module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      // For React Native specific transformations
      'react-native-reanimated/plugin',
    ],
  };
};

===== ./components.json =====
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
===== ./database/dev_target_schema.sql =====
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create rat_migration schema
CREATE SCHEMA IF NOT EXISTS rat;

-- A function for updating the modified_date and modified_by columns
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified_date = CURRENT_TIMESTAMP;
    NEW.modified_by = auth.uid();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create country table
CREATE TABLE dev.country (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE
);

-- Create Organisation table
CREATE TABLE dev.organisation (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100),
    type VARCHAR(50),
    country_id UUID,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (country_id) REFERENCES dev.country(id)
);

ALTER TABLE dev.organisation ADD CONSTRAINT organisation_unique UNIQUE (name);

-- Create location table
--ALTER TABLE dev.location ADD CONSTRAINT location_name_key UNIQUE (name);
CREATE TABLE dev.location (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) UNIQUE NOT NULL,
    country_id UUID,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (country_id) REFERENCES dev.country(id)
);

-- Add check to prevent self-referential routes
-- ADD CONSTRAINT different_locations CHECK (start_location_id != end_location_id);

-- Create Route table
--ALTER TABLE dev.route ADD CONSTRAINT route_name_key UNIQUE (name);
CREATE TABLE dev.route (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) UNIQUE NOT NULL,
    start_location_id UUID,
    end_location_id UUID,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (start_location_id) REFERENCES dev.location(id),
    FOREIGN KEY (end_location_id) REFERENCES dev.location(id)
);

-- Create collection table
CREATE TABLE dev.collection (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    owner VARCHAR(100),
    donor VARCHAR(100),
    storage_location VARCHAR(100),
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE
);

ALTER TABLE dev.collection ADD CONSTRAINT collection_unique UNIQUE (name);

-- Create Photographer table
CREATE TABLE dev.photographer (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE
);

ALTER TABLE dev.photographer ADD CONSTRAINT photographer_unique UNIQUE (name);

-- Create Builder table
CREATE TABLE dev.builder (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(20) UNIQUE NOT NULL,
    name VARCHAR(100),
    location_id UUID,
    plant_code VARCHAR(20),
    builder_plant VARCHAR(100),
    remarks VARCHAR(400),
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (location_id) REFERENCES dev.location(id)
);

ALTER TABLE dev.builder ADD CONSTRAINT builder_unique UNIQUE (code);
--ALTER TABLE dev.builder DROP CONSTRAINT builder_unique;

-- Create Catalog table
CREATE TABLE dev.catalog (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    image_no VARCHAR(50) UNIQUE NOT NULL,
    accession_no DECIMAL(10,2),
    category VARCHAR(50),
    date_taken DATE,
    circa VARCHAR(50),
    imprecise_date VARCHAR(50),
    description TEXT,
    condition VARCHAR(50),
    valuation DECIMAL(10,2),
    entry_date DATE,
    owners_ref VARCHAR(200),
    cd_no VARCHAR(50),
    cd_no_hr VARCHAR(50),
    BW_image_no VARCHAR(50),
    bw_cd_no VARCHAR(50),
    gauge VARCHAR(20),
    works_number VARCHAR(50),
    year_built VARCHAR(20),
    plant_code VARCHAR(20),
    picture VARCHAR(255),
    active_area VARCHAR(100),
    corporate_body VARCHAR(100),
    facility VARCHAR(100),
    parent_folder VARCHAR(255),
    imgref_stem VARCHAR(255),
    website VARCHAR(255),
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE
);

-- Create CatalogMetadata table
CREATE TABLE dev.catalog_metadata (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    catalog_id UUID,
    organisation_id UUID,
    location_id UUID,
    route_id UUID,
    collection_id UUID,
    photographer_id UUID,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (catalog_id) REFERENCES dev.catalog(id),
    FOREIGN KEY (organisation_id) REFERENCES dev.organisation(id),
    FOREIGN KEY (location_id) REFERENCES dev.location(id),
    FOREIGN KEY (route_id) REFERENCES dev.route(id),
    FOREIGN KEY (collection_id) REFERENCES dev.collection(id),
    FOREIGN KEY (photographer_id) REFERENCES dev.photographer(id)
);

ALTER TABLE dev.catalog_metadata DROP CONSTRAINT unique_metadata_combination;
ALTER TABLE dev.catalog_metadata 
ADD CONSTRAINT unique_metadata_combination 
UNIQUE (catalog_id, collection_id, photographer_id, organisation_id, location_id, route_id);

--'catalog_id', 'collection_id', 'photographer_id', 'organisation_id', 'location_id', 'route_id'

-- Create Usage table
CREATE TABLE dev.usage (
    catalog_id UUID,
    prints_allowed BOOLEAN,
    internet_use BOOLEAN,
    publications_use BOOLEAN,
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (catalog_id) REFERENCES dev.catalog(id)
);

ALTER TABLE dev.usage ADD CONSTRAINT usage_unique UNIQUE (catalog_id);

-- Create CatalogBuilder table
CREATE TABLE dev.catalog_builder (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    catalog_id UUID REFERENCES dev.catalog(id),
    builder_id UUID REFERENCES dev.builder(id) NULL,  -- Allow NULL for plant-code-only cases
    builder_order INT NOT NULL,                       -- 1,2,3 to maintain position in image
    plant_code VARCHAR(20),
    works_number VARCHAR(50),
    year_built VARCHAR(20),
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    CONSTRAINT at_least_one_value CHECK (builder_id IS NOT NULL OR plant_code IS NOT NULL OR works_number IS NOT NULL OR year_built IS NOT NULL)
);

ALTER TABLE dev.catalog_builder ADD CONSTRAINT catalog_builder_unique UNIQUE (catalog_id, builder_id, builder_order, plant_code, works_number);

-- Create PictureMetadata table
CREATE TABLE dev.picture_metadata (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    catalog_id UUID REFERENCES dev.catalog(id),
    file_name VARCHAR(50),
    file_location VARCHAR(255),
    file_type VARCHAR(50),
    file_size BIGINT, 
    width INTEGER,
    height INTEGER,
    resolution VARCHAR(50),
    colour_space VARCHAR(50),
    colour_mode VARCHAR(20),
    ai_description TEXT,
    tags TEXT[],
    created_by UUID NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modified_by UUID,
    modified_date TIMESTAMP WITH TIME ZONE,
    FOREIGN KEY (catalog_id) REFERENCES dev.catalog(id)
);

ALTER TABLE dev.picture_metadata ADD CONSTRAINT picture_metadata_unique UNIQUE (catalog_id);

-- Add colour_mode with constraint
ALTER TABLE dev.picture_metadata 
ADD CONSTRAINT valid_colour_mode
CHECK (colour_mode IS NULL OR colour_mode IN ('colour', 'black_and_white', 'grayscale', 'sepia'));

-- Add constraint for existing colour_space column
ALTER TABLE dev.picture_metadata
ADD CONSTRAINT valid_colour_space 
CHECK (colour_space IS NULL OR colour_space IN ('sRGB', 'Adobe RGB', 'ProPhoto RGB', 'CMYK', 'LAB', 'Grayscale'));

-- Add constraints
ALTER TABLE dev.catalog ADD CONSTRAINT check_valuation CHECK (valuation >= 0);
ALTER TABLE dev.catalog ADD CONSTRAINT check_entry_date CHECK (entry_date <= CURRENT_DATE);


-- Add indexes for frequently queried columns:
CREATE INDEX idx_catalog_date_taken ON dev.catalog(date_taken);
CREATE INDEX idx_catalog_gauge ON dev.catalog(gauge);
CREATE INDEX idx_location_country ON dev.location(country_id);


-- Create triggers for updating modified columns
CREATE TRIGGER update_country_modtime BEFORE UPDATE ON dev.country FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_organisation_modtime BEFORE UPDATE ON dev.organisation FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_location_modtime BEFORE UPDATE ON dev.location FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_route_modtime BEFORE UPDATE ON dev.route FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_collection_modtime BEFORE UPDATE ON dev.collection FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_photographer_modtime BEFORE UPDATE ON dev.photographer FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_builder_modtime BEFORE UPDATE ON dev.builder FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_catalog_modtime BEFORE UPDATE ON dev.catalog FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_catalog_metadata_modtime BEFORE UPDATE ON dev.catalog_metadata FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_usage_modtime BEFORE UPDATE ON dev.usage FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_catalog_builder_modtime BEFORE UPDATE ON dev.catalog_builder FOR EACH ROW EXECUTE FUNCTION update_modified_column();
CREATE TRIGGER update_picture_metadata_modtime BEFORE UPDATE ON dev.picture_metadata FOR EACH ROW EXECUTE FUNCTION update_modified_column();

-- Enable Row Level Security (RLS) on all tables
ALTER TABLE dev.country ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.organisation ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.location ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.route ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.collection ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.photographer ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.builder ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.catalog ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.catalog_metadata ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.catalog_builder ENABLE ROW LEVEL SECURITY;
ALTER TABLE dev.picture_metadata ENABLE ROW LEVEL SECURITY;

-- Create basic RLS policies (you may want to adjust these based on your specific requirements)
CREATE POLICY "Users can view all records" ON dev.country FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.organisation FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.location FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.route FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.collection FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.photographer FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.builder FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.catalog FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.catalog_metadata FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.usage FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.catalog_builder FOR SELECT USING (true);
CREATE POLICY "Users can view all records" ON dev.picture_metadata FOR SELECT USING (true);



-- Example of a more restrictive policy (uncomment and modify as needed)
-- CREATE POLICY "Users can update their own records" ON catalog FOR UPDATE USING (auth.uid() = created_by);

--- View

--- Mobile App View and Indexes

-- Create indexes to optimize view performance
CREATE INDEX IF NOT EXISTS idx_catalog_image_no ON dev.catalog(image_no);
CREATE INDEX IF NOT EXISTS idx_catalog_date_taken ON dev.catalog(date_taken);
CREATE INDEX IF NOT EXISTS idx_catalog_category ON dev.catalog(category);
CREATE INDEX IF NOT EXISTS idx_catalog_gauge ON dev.catalog(gauge);
CREATE INDEX IF NOT EXISTS idx_catalog_year_built ON dev.catalog(year_built);

CREATE INDEX IF NOT EXISTS idx_catalog_metadata_catalog_id ON dev.catalog_metadata(catalog_id);
CREATE INDEX IF NOT EXISTS idx_catalog_metadata_organisation_id ON dev.catalog_metadata(organisation_id);
CREATE INDEX IF NOT EXISTS idx_catalog_metadata_location_id ON dev.catalog_metadata(location_id);
CREATE INDEX IF NOT EXISTS idx_catalog_metadata_route_id ON dev.catalog_metadata(route_id);
CREATE INDEX IF NOT EXISTS idx_catalog_metadata_collection_id ON dev.catalog_metadata(collection_id);
CREATE INDEX IF NOT EXISTS idx_catalog_metadata_photographer_id ON dev.catalog_metadata(photographer_id);

CREATE INDEX IF NOT EXISTS idx_catalog_builder_catalog_id ON dev.catalog_builder(catalog_id);
CREATE INDEX IF NOT EXISTS idx_catalog_builder_builder_id ON dev.catalog_builder(builder_id);

CREATE INDEX IF NOT EXISTS idx_usage_catalog_id ON dev.usage(catalog_id);
CREATE INDEX IF NOT EXISTS idx_picture_metadata_catalog_id ON dev.picture_metadata(catalog_id);

-- Drop existing view if exists
DROP VIEW IF EXISTS dev.mobile_catalog_view;

-- Create the mobile app view with thumbnail URL
CREATE OR REPLACE VIEW dev.mobile_catalog_view AS
SELECT 
    -- Primary image information
    c.image_no,
    c.category,
    c.date_taken,
    c.circa,
    c.imprecise_date,
    c.description,
    c.gauge,
    
    -- Thumbnail URL construction
    CONCAT('https://cdn.example.com/thumbnails/', c.image_no, '.webp') AS thumbnail_url,
    
    -- Location and route information
    cnt.name AS country,
    org.name AS organisation,
    org.type AS organisation_type,
    l.name AS location,
    r.name AS route,
    
    -- Collection and photographer details
    col.name AS collection,
    p.name AS photographer,
    
    -- Usage rights
    u.prints_allowed,
    u.internet_use,
    u.publications_use,
    
    -- Builder information (as JSON array for easier mobile consumption)
    ARRAY_AGG(DISTINCT jsonb_build_object(
        'builder_name', b.name,
        'builder_code', b.code,
        'works_number', cb.works_number,
        'year_built', cb.year_built,
        'plant_code', cb.plant_code,
        'builder_order', cb.builder_order
    )) FILTER (WHERE b.id IS NOT NULL) AS builders,
    
    -- Image metadata
    pm.file_type,
    pm.width,
    pm.height,
    pm.resolution,
    pm.colour_space,
    pm.colour_mode,
    
    -- Reference numbers
    c.cd_no,
    c.cd_no_hr,
    c.BW_image_no,
    c.bw_cd_no,
    
    -- Additional metadata
    c.active_area,
    c.corporate_body,
    c.facility,
    
    -- Timestamps for caching/syncing
    c.modified_date AS last_updated

FROM 
    dev.catalog c
    LEFT JOIN dev.catalog_metadata cm ON c.id = cm.catalog_id
    LEFT JOIN dev.organisation org ON cm.organisation_id = org.id
    LEFT JOIN dev.country cnt ON org.country_id = cnt.id
    LEFT JOIN dev.location l ON cm.location_id = l.id
    LEFT JOIN dev.route r ON cm.route_id = r.id
    LEFT JOIN dev.collection col ON cm.collection_id = col.id
    LEFT JOIN dev.photographer p ON cm.photographer_id = p.id
    LEFT JOIN dev.usage u ON c.id = u.catalog_id
    LEFT JOIN dev.catalog_builder cb ON c.id = cb.catalog_id
    LEFT JOIN dev.builder b ON cb.builder_id = b.id
    LEFT JOIN dev.picture_metadata pm ON c.id = pm.catalog_id

GROUP BY 
    c.id,
    c.image_no,
    c.category,
    c.date_taken,
    c.circa,
    c.imprecise_date,
    c.description,
    c.gauge,
    cnt.name,
    org.name,
    org.type,
    l.name,
    r.name,
    col.name,
    p.name,
    u.prints_allowed,
    u.internet_use,
    u.publications_use,
    pm.file_type,
    pm.width,
    pm.height,
    pm.resolution,
    pm.colour_space,
    pm.colour_mode,
    c.cd_no,
    c.cd_no_hr,
    c.BW_image_no,
    c.bw_cd_no,
    c.active_area,
    c.corporate_body,
    c.facility,
    c.modified_date;

-- Add comment explaining the view
COMMENT ON VIEW dev.mobile_catalog_view IS 'Comprehensive view of catalog entries optimized for mobile app usage. Includes image details, location info, builders, and CDN-served thumbnail URLs.';

-- Grant permissions
GRANT SELECT ON dev.mobile_catalog_view TO authenticated;

-- Create indexes on the most commonly queried columns in the view
CREATE INDEX IF NOT EXISTS idx_mobile_view_date ON dev.catalog(date_taken) 
WHERE date_taken IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_mobile_view_country ON dev.country(name) 
WHERE name IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_mobile_view_location ON dev.location(name) 
WHERE name IS NOT NULL;

-- Add a gin index for text search on description
CREATE INDEX IF NOT EXISTS idx_catalog_description_gin ON dev.catalog 
USING gin(to_tsvector('english', description));

-- Add a gin index for tags array searching
CREATE INDEX IF NOT EXISTS idx_picture_metadata_tags_gin ON dev.picture_metadata 
USING gin(tags);




--- Query

-- Basic search
SELECT image_no, thumbnail_url, description, date_taken 
FROM dev.mobile_catalog_view 
WHERE location = 'London'
ORDER BY date_taken DESC
LIMIT 20;

-- Search by builder
SELECT image_no, thumbnail_url, description 
FROM dev.mobile_catalog_view 
WHERE builders @> '[{"builder_name": "Swindon Works"}]'::jsonb;

-- Full text search in description
SELECT image_no, thumbnail_url, description 
FROM dev.mobile_catalog_view 
WHERE to_tsvector('english', description) @@ to_tsquery('english', 'steam & engine')
LIMIT 20;



-- Supabase stored procedure to get total size
CREATE OR REPLACE FUNCTION total_size_in_bucket(bucket_name text, bucket_prefix text)
RETURNS bigint AS $$
BEGIN
    RETURN (SELECT COALESCE(SUM((metadata->>'size')::bigint), 0) 
            FROM storage.objects 
            WHERE bucket_id = bucket_name 
            AND name LIKE bucket_prefix || '%');
END;
$$ LANGUAGE plpgsql;

-- Test
SELECT total_size_in_bucket('rat', 'images/');


-- reload cache??
NOTIFY pgrst, 'reload schema';

DROP FUNCTION reduce_storage_lifo(text,text,bigint)

-- Purge storage to a certain size
CREATE OR REPLACE FUNCTION public.reduce_storage_lifo(
    bucket_name text,
    bucket_prefix text,
    max_size_bytes bigint
) RETURNS bigint AS $$
DECLARE
    current_size bigint;
    file_row record;
BEGIN
    -- Get initial size
    SELECT COALESCE(SUM(NULLIF((metadata->>'size')::bigint, NULL)), 0) INTO current_size
    FROM storage.objects 
    WHERE bucket_id = bucket_name 
    AND name LIKE bucket_prefix || '%';

    -- Loop to delete files until we're under the threshold
    FOR file_row IN 
        SELECT id, name, (metadata->>'size')::bigint AS file_size
        FROM storage.objects 
        WHERE bucket_id = bucket_name 
        AND name LIKE bucket_prefix || '%'
        ORDER BY created_at DESC -- LIFO: most recently added first
    LOOP
        IF current_size <= max_size_bytes THEN
            EXIT;
        END IF;
        
        -- Delete the file
        DELETE FROM storage.objects WHERE id = file_row.id;
        
        -- Update current size
        current_size := current_size - file_row.file_size;
        
        RAISE NOTICE 'Deleted file: % - Size reduced by % bytes', file_row.name, file_row.file_size;
    END LOOP;

    -- Return the final size
    RETURN current_size;
END;
$$ LANGUAGE plpgsql;


select reduce_storage_lifo('rat', 'images/', 1073741824);
===== ./eslint.config.js =====
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);

===== ./expo/metro.config.js =====
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('@expo/metro-config');

const config = getDefaultConfig(__dirname);

// Add any additional configuration if needed
config.resolver.sourceExts = ['jsx', 'js', 'ts', 'tsx', 'json'];

module.exports = config;
===== ./expo-start.js =====

#!/usr/bin/env node

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Make sure assets directory exists
const assetsDir = path.join(__dirname, 'assets');
if (!fs.existsSync(assetsDir)) {
  fs.mkdirSync(assetsDir);
  
  // Create placeholder images
  const placeholders = ['icon.png', 'splash.png', 'adaptive-icon.png', 'favicon.png'];
  placeholders.forEach(file => {
    fs.copyFileSync(
      path.join(__dirname, 'public', 'placeholder.svg'),
      path.join(assetsDir, file)
    );
  });
}

// Start Expo
const expo = spawn('npx', ['expo', 'start'], {
  stdio: 'inherit',
  shell: true
});

expo.on('close', code => {
  process.exit(code);
});

===== ./package.json =====
{
  "name": "trainpixelfolio",
  "private": true,
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "build:dev": "expo start --dev-client",
    "build:android": "expo run:android",
    "build:ios": "expo run:ios"
  },
  "dependencies": {
    "@expo/metro-config": "^0.19.12",
    "@expo/vector-icons": "^14.0.0",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-native-community/netinfo": "11.4.1",
    "@react-navigation/bottom-tabs": "^6.5.8",
    "@react-navigation/native": "^6.1.7",
    "@react-navigation/native-stack": "^6.9.13",
    "@supabase/supabase-js": "^2.49.1",
    "@types/react-router-dom": "^5.3.3",
    "check": "^1.0.0",
    "class-variance-authority": "^0.7.1",
    "expo": "^52.0.40",
    "expo-font": "~13.0.4",
    "expo-image": "~2.0.7",
    "expo-splash-screen": "^0.29.22",
    "expo-status-bar": "~2.0.1",
    "lottie-react-native": "7.1.0",
    "lucide-react": "^0.483.0",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-device-info": "10.13.2",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-haptic-feedback": "2.3.3",
    "react-native-linear-gradient": "2.8.3",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-webview": "13.12.5",
    "tailwind-merge": "^3.0.2"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "18.3.1",
    "@types/react-native": "^0.72.8",
    "@vitejs/plugin-react-swc": "^3.8.1",
    "lovable-tagger": "^1.1.7",
    "typescript": "^5.1.3"
  }
}

===== ./postcss.config.js =====
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

===== ./README.md =====

# TrainPhoto Mobile App

A React Native mobile application for train photography enthusiasts, built with Expo SDK 52.0.0.

## Features

- Browse train photos by category
- View detailed information about photos
- Add photos to cart for purchase
- User authentication (login/register)
- Admin dashboard for content management

## Color Scheme

- Primary: Dark Blue (#1A237E)
- Secondary: Red (#D32F2F)
- Background: White (#FFFFFF)

## Getting Started

### Prerequisites

- Node.js (v18 or later)
- npm or yarn
- Expo CLI (`npm install -g expo-cli`)
- iOS Simulator (for Mac users) or Android Emulator
- Expo Go app on your physical device (optional)

### Installation

1. Clone the repository
```
git clone https://github.com/blueairblob/trainpixelfolio.git
cd trainpixelfolio
```

2. Install dependencies:
```
npm install
```

3. Start the Expo development server:
```
npx expo start
```

4. Run on a simulator or scan the QR code with the Expo Go app on your device

### Login Credentials

For testing purposes, you can use these accounts:

- Admin: admin@example.com / admin123
- Regular User: user@example.com / user123

## Deployment

This app can be deployed using Expo EAS Build:

```
npx eas build:configure
npx eas build --platform ios
npx eas build --platform android
```

## Project Structure

- `/src/screens` - Main application screens
- `/src/components` - Reusable UI components
- `/src/services` - API and business logic
- `/assets` - Images and other static assets

## Technologies Used

- React Native 0.78.0
- React 19.0.0
- Expo SDK 52.0.0
- React Navigation
- Async Storage for local data persistence
- Tailwind CSS (via TWRNC)
- Expo Vector Icons

===== ./src/components/AdvancedFilterModal.tsx =====
import React, { useState } from 'react';
import {
  View,
  Text,
  Modal,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFilters } from '@/context/FilterContext';
import OrganisationFilter from './filters/OrganisationFilter';
import DateRangeFilter from './filters/DateRangeFilter';

interface AdvancedFilterModalProps {
  visible: boolean;
  onClose: () => void;
  onApplyFilters: () => void;
  resultCount?: number;
  hasMoreResults?: boolean;
}

const AdvancedFilterModal: React.FC<AdvancedFilterModalProps> = ({
  visible,
  onClose,
  onApplyFilters,
  resultCount,
  hasMoreResults = false,
}) => {
  const {
    filters,
    setOrganisation,
    setDateRange, // Add this line
    clearAllFilters,
    isLoading,
    filteredResults,
    hasActiveFilters,
  } = useFilters();

  // Active filter count in this modal for badge display
  const [activeTabIndex, setActiveTabIndex] = useState(0);
  const tabs = ['Basic Filters', 'Advanced Filters'];

  // Handle apply filters
  const handleApplyFilters = () => {
    onApplyFilters();
    onClose();
  };

  // Handle reset filters
  const handleResetFilters = () => {
    clearAllFilters();
  };

  // Get the real-time count from either filtered results or passed in resultCount
  const displayCount = filteredResults.length > 0 
    ? filteredResults.length 
    : resultCount || 0;

  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={visible}
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          {/* Header */}
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Filters</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close-outline" size={24} color="#4b5563" />
            </TouchableOpacity>
          </View>

          {/* Tabs */}
          <View style={styles.tabsContainer}>
            {tabs.map((tab, index) => (
              <TouchableOpacity
                key={tab}
                style={[
                  styles.tab,
                  activeTabIndex === index && styles.activeTab,
                ]}
                onPress={() => setActiveTabIndex(index)}
              >
                <Text
                  style={[
                    styles.tabText,
                    activeTabIndex === index && styles.activeTabText,
                  ]}
                >
                  {tab}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Filter content area */}
          <View style={styles.contentContainer}>
            {activeTabIndex === 0 ? (
              <View style={styles.filterSection}>
                {/* Organisation Filter */}
                <OrganisationFilter
                  onSelect={setOrganisation}
                  selectedOrganisation={filters.organisation}
                  label="Organisation"
                />

                {/* Date Range Filter */}
                <DateRangeFilter
                  label="Date Taken"
                  value={{
                    startDate: filters.dateRange?.startDate ? new Date(filters.dateRange.startDate) : null,
                    endDate: filters.dateRange?.endDate ? new Date(filters.dateRange.endDate) : null
                  }}
                  onChange={range => {
                    setDateRange({
                      startDate: range.startDate ? range.startDate.toISOString().split('T')[0] : null,
                      endDate: range.endDate ? range.endDate.toISOString().split('T')[0] : null
                    });
                  }}
                  placeholder="Filter by date range"
                />
                
                {/* Placeholder for future basic filters */}
                <View style={styles.comingSoonContainer}>
                  <Text style={styles.comingSoonText}>
                    More filters coming soon...
                  </Text>
                </View>
              </View>
            ) : (
              <View style={styles.filterSection}>
                {/* Placeholder for advanced filters */}
                <View style={styles.comingSoonContainer}>
                  <Text style={styles.comingSoonText}>
                    Advanced filters coming soon...
                  </Text>
                  <Text style={styles.comingSoonSubtext}>
                    These will include technical specifications, metadata filters, 
                    and more detailed search options.
                  </Text>
                </View>
              </View>
            )}
          </View>

          {/* Real-time loading indicator */}
          {isLoading && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator size="large" color="#4f46e5" />
              <Text style={styles.loadingText}>Updating filters...</Text>
            </View>
          )}

          {/* Action buttons and result count */}
          <View style={styles.actionButtonsContainer}>
            {/* Result count display */}
            <Text style={styles.resultCountText}>
              {isLoading 
                ? "Calculating results..." 
                : `${displayCount} ${displayCount === 1 ? 'result' : 'results'} ${hasMoreResults ? '+' : ''}`}
            </Text>

            <View style={styles.actionButtons}>
              <TouchableOpacity
                style={styles.resetButton}
                onPress={handleResetFilters}
              >
                <Text style={styles.resetButtonText}>Reset</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.applyButton}
                onPress={handleApplyFilters}
              >
                <Text style={styles.applyButtonText}>Apply Filters</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingBottom: 24,
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  closeButton: {
    padding: 4,
  },
  tabsContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#4f46e5',
  },
  tabText: {
    fontSize: 14,
    color: '#6b7280',
  },
  activeTabText: {
    color: '#4f46e5',
    fontWeight: '600',
  },
  scrollView: {
    maxHeight: '70%',
    flex: 1,
  },
  filterSection: {
    padding: 16,
  },
  comingSoonContainer: {
    backgroundColor: '#f9fafb',
    borderRadius: 8,
    padding: 16,
    marginVertical: 16,
    alignItems: 'center',
  },
  comingSoonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 8,
  },
  comingSoonSubtext: {
    fontSize: 13,
    color: '#6b7280',
    textAlign: 'center',
  },
  loadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 14,
    color: '#4b5563',
  },
  actionButtonsContainer: {
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  resultCountText: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 12,
    textAlign: 'center',
  },
  actionButtons: {
    flexDirection: 'row',
  },
  resetButton: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    marginRight: 8,
  },
  resetButtonText: {
    fontSize: 16,
    color: '#4b5563',
  },
  applyButton: {
    flex: 2,
    paddingVertical: 12,
    alignItems: 'center',
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    marginLeft: 8,
  },
  applyButtonText: {
    fontSize: 16,
    color: '#ffffff',
    fontWeight: '600',
  },
  contentContainer: {
    maxHeight: '70%',
  },
});

export default AdvancedFilterModal;
===== ./src/components/CategoriesSection.tsx =====
// CategoriesSection.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface Category {
  id: string;
  title: string;
  icon: string;
}

interface CategoriesSectionProps {
  categories: Category[];
  onCategoryPress: (categoryId: string) => void;
}

const CategoriesSection = ({ categories, onCategoryPress }: CategoriesSectionProps) => {
  return (
    <View style={styles.sectionContainer}>
      <Text style={styles.sectionTitle}>Browse Categories</Text>
      <View style={styles.categoriesGrid}>
        {categories.map((category) => (
          <TouchableOpacity 
            key={category.id}
            style={styles.categoryCard}
            onPress={() => onCategoryPress(category.id)}
          >
            <Ionicons name={category.icon as any} size={24} color="#4f46e5" />
            <Text style={styles.categoryTitle}>{category.title}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  sectionContainer: {
    marginBottom: 24,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: 16,
    color: '#1f2937',
  },
  categoriesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  categoryCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    width: '48%',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  categoryTitle: {
    marginTop: 8,
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
    textAlign: 'center',
  },
});

export default CategoriesSection;

===== ./src/components/CategoryFilter.tsx =====
// CategoryFilter.tsx
import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';

interface Category {
  id: string;
  title: string;
}

interface CategoryFilterProps {
  categories: Category[];
  activeCategory: string;
  onCategoryPress: (category: string) => void;
}

const CategoryFilter = ({
  categories,
  activeCategory,
  onCategoryPress,
}: CategoryFilterProps) => {
  return (
    <ScrollView
      horizontal
      showsHorizontalScrollIndicator={false}
      contentContainerStyle={styles.container}
    >
      {categories.map((category) => (
        <TouchableOpacity
          key={category.id}
          style={[
            styles.categoryItem,
            activeCategory === category.id && styles.activeCategoryItem,
          ]}
          onPress={() => onCategoryPress(category.id)}
        >
          <Text
            style={[
              styles.categoryText,
              activeCategory === category.id && styles.activeCategoryText,
            ]}
            numberOfLines={1}
          >
            {category.title}
          </Text>
        </TouchableOpacity>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    flexDirection: 'row',
    alignItems: 'center',
  },
  categoryItem: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#f3f4f6',
    marginRight: 8,
    minWidth: 100,  // Set a minimum width
    alignItems: 'center',
  },
  activeCategoryItem: {
    backgroundColor: '#4f46e5',
  },
  categoryText: {
    fontSize: 14,
    color: '#4b5563',
  },
  activeCategoryText: {
    color: '#ffffff',
    fontWeight: '500',
  },
});

export default CategoryFilter;

===== ./src/components/FeaturedPhotoSection.tsx =====
// FeaturedPhotoSection.tsx
import React from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface FeaturedPhoto {
  id: string;
  title: string;
  description: string;
  photographer: string;
  location: string;
  price: number;
  imageUrl: string;
}

interface FeaturedPhotoSectionProps {
  featuredPhoto: FeaturedPhoto;
  onViewDetailsPress: (photoId: string) => void;
}

const FeaturedPhotoSection = ({ featuredPhoto, onViewDetailsPress }: FeaturedPhotoSectionProps) => {
  return (
    <View style={styles.sectionContainer}>
      <Text style={styles.sectionTitle}>Featured Photo</Text>
      <View style={styles.featuredCard}>
        <Image 
          source={{ uri: featuredPhoto.imageUrl }}
          style={styles.featuredImage}
          resizeMode="cover"
        />
        <View style={styles.featuredContent}>
          <View style={styles.featuredBadge}>
            <Ionicons name="star" size={12} color="#ffffff" />
            <Text style={styles.featuredBadgeText}>Featured</Text>
          </View>
          <Text style={styles.featuredTitle}>{featuredPhoto.title}</Text>
          <Text style={styles.featuredDescription}>{featuredPhoto.description}</Text>
          <View style={styles.photographerRow}>
            <Text style={styles.photographerText}>By {featuredPhoto.photographer}</Text>
            <Text style={styles.locationText}>{featuredPhoto.location}</Text>
          </View>
          <View style={styles.featuredPrice}>
            <Text style={styles.priceText}>${featuredPhoto.price.toFixed(2)}</Text>
            <Text style={styles.licenseText}>Standard license</Text>
          </View>
          <TouchableOpacity 
            style={styles.viewDetailsButton}
            onPress={() => onViewDetailsPress(featuredPhoto.id)}
          >
            <Text style={styles.viewDetailsText}>View Details</Text>
            <Ionicons name="arrow-forward" size={16} color="#4f46e5" />
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  sectionContainer: {
    marginBottom: 24,
    paddingHorizontal: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: 16,
    color: '#1f2937',
  },
  featuredCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  featuredImage: {
    width: '100%',
    height: 200,
  },
  featuredContent: {
    padding: 16,
  },
  featuredBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4f46e5',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 16,
    alignSelf: 'flex-start',
    marginBottom: 12,
  },
  featuredBadgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
    marginLeft: 4,
  },
  featuredTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 8,
  },
  featuredDescription: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 12,
  },
  photographerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  photographerText: {
    fontSize: 13,
    color: '#374151',
    fontWeight: '500',
  },
  locationText: {
    fontSize: 13,
    color: '#6b7280',
  },
  featuredPrice: {
    flexDirection: 'row',
    alignItems: 'baseline',
    marginBottom: 16,
  },
  priceText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#1f2937',
    marginRight: 8,
  },
  licenseText: {
    fontSize: 12,
    color: '#6b7280',
  },
  viewDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#f3f4f6',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  viewDetailsText: {
    color: '#4f46e5',
    fontWeight: '600',
    marginRight: 8,
  },
});

export default FeaturedPhotoSection;

===== ./src/components/FilterDebugger.tsx =====
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { supabase } from '@/integrations/supabase/client';
import { useFilters } from '@/context/FilterContext';

/**
 * Debug component to help troubleshoot filtering issues
 * Add this to your GalleryScreen or anywhere you need to debug the filter behavior
 */
const FilterDebugger: React.FC = () => {
  const { filters, applyFilters, hasActiveFilters } = useFilters();
  const [rawResults, setRawResults] = useState<any[]>([]);
  const [expanded, setExpanded] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Function to run a simplified test query
  const runTestQuery = async () => {
    if (!hasActiveFilters) {
      setRawResults([]);
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      console.log('FilterDebugger: Running test query with filters', JSON.stringify(filters, null, 2));
      
      // Create a basic query 
      let query = supabase
        .from('mobile_catalog_view')
        .select('image_no, description, organisation')
        .limit(10);
      
      // Apply specific filter for organization manually
      if (filters.organisation) {
        console.log(`FilterDebugger: Testing organization filter with "${filters.organisation.name}"`);
        
        // Try different filter approaches
        // 1. Simple equality (exact match)
        // query = query.eq('organisation', filters.organisation.name);
        
        // 2. Case-insensitive LIKE
        query = query.ilike('organisation', `%${filters.organisation.name}%`);
        
        // 3. Raw SQL (if Supabase supports it)
        // query = query.or(`organisation.ilike.%${filters.organisation.name}%`);
        
        console.log(`FilterDebugger: Applied filter`);
      }
      
      const { data, error: queryError } = await query;
      
      if (queryError) {
        console.error('FilterDebugger: Query error:', queryError);
        throw new Error(queryError.message);
      }
      
      console.log(`FilterDebugger: Query returned ${data?.length || 0} results`);
      if (data && data.length > 0) {
        console.log('FilterDebugger: First result sample:', data[0]);
      }
      
      setRawResults(data || []);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      console.error('FilterDebugger: Test query error:', errorMessage);
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // Toggle expanded view
  const toggleExpand = () => {
    setExpanded(!expanded);
    if (!expanded && hasActiveFilters) {
      runTestQuery();
    }
  };

  return (
    <View style={styles.container}>
      <TouchableOpacity 
        style={styles.header} 
        onPress={toggleExpand}
        activeOpacity={0.7}
      >
        <Text style={styles.title}>Filter Debugger</Text>
        <Text style={styles.toggleText}>
          {expanded ? 'Hide' : 'Show'} Details
        </Text>
      </TouchableOpacity>
      
      {expanded && (
        <ScrollView style={styles.content}>
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Active Filters:</Text>
            <Text style={styles.code}>
              {JSON.stringify(filters, null, 2)}
            </Text>
          </View>
          
          <TouchableOpacity 
            style={styles.button}
            onPress={runTestQuery}
            disabled={isLoading || !hasActiveFilters}
          >
            <Text style={styles.buttonText}>
              {isLoading ? 'Running Test Query...' : 'Run Test Query'}
            </Text>
          </TouchableOpacity>
          
          {error && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>Error: {error}</Text>
            </View>
          )}
          
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>
              Raw Results: {rawResults.length} item(s)
            </Text>
            {rawResults.length > 0 ? (
              <Text style={styles.code}>
                {JSON.stringify(rawResults.slice(0, 3), null, 2)}
                {rawResults.length > 3 && '\n... (and more)'}
              </Text>
            ) : (
              <Text style={styles.emptyText}>
                {hasActiveFilters 
                  ? 'No results found for current filters' 
                  : 'No active filters to test'}
              </Text>
            )}
          </View>
          
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Troubleshooting Tips:</Text>
            <Text style={styles.tipText}>
              • Check if your organization name matches exactly what's in the database
            </Text>
            <Text style={styles.tipText}>
              • Try using partial matching with % wildcards (ilike)
            </Text>
            <Text style={styles.tipText}>
              • Verify column names match exactly what's in the database
            </Text>
            <Text style={styles.tipText}>
              • Check that you're querying the correct table/view
            </Text>
          </View>
        </ScrollView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    margin: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e5e7eb',
    backgroundColor: '#ffffff',
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f3f4f6',
    padding: 12,
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#4f46e5',
  },
  toggleText: {
    fontSize: 14,
    color: '#6b7280',
  },
  content: {
    padding: 12,
    maxHeight: 400,
  },
  section: {
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1f2937',
    marginBottom: 8,
  },
  code: {
    fontFamily: 'monospace',
    fontSize: 12,
    color: '#374151',
    backgroundColor: '#f9fafb',
    padding: 8,
    borderRadius: 4,
  },
  button: {
    backgroundColor: '#4f46e5',
    padding: 12,
    borderRadius: 6,
    alignItems: 'center',
    marginVertical: 12,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  errorContainer: {
    backgroundColor: '#fee2e2',
    padding: 8,
    borderRadius: 4,
    marginBottom: 12,
  },
  errorText: {
    color: '#dc2626',
    fontSize: 12,
  },
  emptyText: {
    color: '#6b7280',
    fontStyle: 'italic',
    fontSize: 14,
    textAlign: 'center',
    padding: 12,
  },
  tipText: {
    fontSize: 12,
    color: '#4b5563',
    marginBottom: 4,
    paddingLeft: 8,
  },
});

export default FilterDebugger;
===== ./src/components/FilterModal.tsx =====
// FilterModal.tsx
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  Modal, 
  TouchableOpacity, 
  StyleSheet, 
  ScrollView,
  Switch
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface Category {
  id: string;
  title: string;
}

interface FilterModalProps {
  visible: boolean;
  onClose: () => void;
  categories: Category[];
  activeCategory: string;
  onCategoryPress: (category: string) => void;
  onClearFilters: () => void;
  resultCount?: number; // Current result count
  hasMoreResults?: boolean; // Whether there are more results available
}

const FilterModal = ({ 
  visible, 
  onClose, 
  categories, 
  activeCategory, 
  onCategoryPress,
  onClearFilters,
  resultCount,
  hasMoreResults = false
}: FilterModalProps) => {
  // Add state for additional filters
  const [priceRange, setPriceRange] = useState([0, 100]);
  const [selectedLocations, setSelectedLocations] = useState<string[]>([]);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [orientation, setOrientation] = useState<string | null>(null);
  
  // Sample data for dropdowns
  const locations = ['London', 'Paris', 'New York', 'Tokyo', 'Sydney'];
  const tags = ['Vintage', 'Modern', 'Black and White', 'Landscape', 'Portrait'];
  
  // Toggle location selection
  const toggleLocation = (location: string) => {
    if (selectedLocations.includes(location)) {
      setSelectedLocations(selectedLocations.filter(loc => loc !== location));
    } else {
      setSelectedLocations([...selectedLocations, location]);
    }
  };
  
  // Toggle tag selection
  const toggleTag = (tag: string) => {
    if (selectedTags.includes(tag)) {
      setSelectedTags(selectedTags.filter(t => t !== tag));
    } else {
      setSelectedTags([...selectedTags, tag]);
    }
  };
  
  // Apply filters
  const applyFilters = () => {
    // Here we would combine all filters and apply them
    // For now, we'll just close the modal
    onClose();
  };
  
  // Reset all filters
  const resetFilters = () => {
    setSelectedLocations([]);
    setSelectedTags([]);
    setOrientation(null);
    setPriceRange([0, 100]);
    onClearFilters();
  };

  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={visible}
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          {/* Header */}
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Filter Photos</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close-outline" size={24} color="#4b5563" />
            </TouchableOpacity>
          </View>
          
          <ScrollView style={styles.scrollView}>
            {/* Categories */}
            <View style={styles.filterSection}>
              <Text style={styles.sectionTitle}>Categories</Text>
              <View style={styles.categoriesContainer}>
                {categories.map((category) => (
                  <TouchableOpacity
                    key={category.id}
                    style={[
                      styles.categoryItem,
                      activeCategory === category.id && styles.activeCategoryItem
                    ]}
                    onPress={() => onCategoryPress(category.id)}
                  >
                    <Text 
                      style={[
                        styles.categoryText,
                        activeCategory === category.id && styles.activeCategoryText
                      ]}
                    >
                      {category.title}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            {/* Locations Dropdown */}
            <View style={styles.filterSection}>
              <Text style={styles.sectionTitle}>Locations</Text>
              <View style={styles.optionsContainer}>
                {locations.map((location) => (
                  <TouchableOpacity 
                    key={location}
                    style={styles.optionRow}
                    onPress={() => toggleLocation(location)}
                  >
                    <Text style={styles.optionText}>{location}</Text>
                    <View style={[
                      styles.checkbox,
                      selectedLocations.includes(location) && styles.checkboxSelected
                    ]}>
                      {selectedLocations.includes(location) && (
                        <Ionicons name="checkmark" size={16} color="#ffffff" />
                      )}
                    </View>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            {/* Tags Dropdown */}
            <View style={styles.filterSection}>
              <Text style={styles.sectionTitle}>Tags</Text>
              <View style={styles.optionsContainer}>
                {tags.map((tag) => (
                  <TouchableOpacity 
                    key={tag}
                    style={styles.optionRow}
                    onPress={() => toggleTag(tag)}
                  >
                    <Text style={styles.optionText}>{tag}</Text>
                    <View style={[
                      styles.checkbox,
                      selectedTags.includes(tag) && styles.checkboxSelected
                    ]}>
                      {selectedTags.includes(tag) && (
                        <Ionicons name="checkmark" size={16} color="#ffffff" />
                      )}
                    </View>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
            
            {/* Orientation Filter */}
            <View style={styles.filterSection}>
              <Text style={styles.sectionTitle}>Orientation</Text>
              <View style={styles.orientationContainer}>
                <TouchableOpacity 
                  style={[
                    styles.orientationButton, 
                    orientation === 'landscape' && styles.activeOrientationButton
                  ]}
                  onPress={() => setOrientation(orientation === 'landscape' ? null : 'landscape')}
                >
                  <Text style={[
                    styles.orientationText,
                    orientation === 'landscape' && styles.activeOrientationText
                  ]}>
                    Landscape
                  </Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                  style={[
                    styles.orientationButton, 
                    orientation === 'portrait' && styles.activeOrientationButton
                  ]}
                  onPress={() => setOrientation(orientation === 'portrait' ? null : 'portrait')}
                >
                  <Text style={[
                    styles.orientationText,
                    orientation === 'portrait' && styles.activeOrientationText
                  ]}>
                    Portrait
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </ScrollView>
          
          {/* Action Buttons with Result Count */}
          <View style={styles.actionButtonsContainer}>
            {/* Display current result count if available */}
            {resultCount !== undefined && (
              <Text style={styles.resultCountText}>
                Currently showing {resultCount} {resultCount === 1 ? 'photo' : 'photos'}
                {hasMoreResults ? '+' : ''}
              </Text>
            )}
            
            <View style={styles.actionButtons}>
              <TouchableOpacity 
                style={styles.resetButton} 
                onPress={resetFilters}
              >
                <Text style={styles.resetButtonText}>Reset</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.applyButton}
                onPress={applyFilters}
              >
                <Text style={styles.applyButtonText}>Apply Filters</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingBottom: 24,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  closeButton: {
    padding: 4,
  },
  scrollView: {
    maxHeight: '70%',
  },
  filterSection: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
    marginBottom: 12,
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  categoryItem: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    backgroundColor: '#f3f4f6',
    marginHorizontal: 4,
    marginBottom: 8,
  },
  activeCategoryItem: {
    backgroundColor: '#4f46e5',
  },
  categoryText: {
    color: '#4b5563',
    fontSize: 14,
  },
  activeCategoryText: {
    color: '#ffffff',
  },
  optionsContainer: {
    marginTop: 8,
  },
  optionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  optionText: {
    fontSize: 16,
    color: '#1f2937',
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 4,
    borderWidth: 2,
    borderColor: '#d1d5db',
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxSelected: {
    backgroundColor: '#4f46e5',
    borderColor: '#4f46e5',
  },
  orientationContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  orientationButton: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    marginHorizontal: 4,
  },
  activeOrientationButton: {
    backgroundColor: '#4f46e5',
    borderColor: '#4f46e5',
  },
  orientationText: {
    fontSize: 16,
    color: '#4b5563',
  },
  activeOrientationText: {
    color: '#ffffff',
  },
  // Updated action buttons container
  actionButtonsContainer: {
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  // New result count text style
  resultCountText: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 12,
    textAlign: 'center',
  },
  // Updated action buttons style
  actionButtons: {
    flexDirection: 'row',
  },
  resetButton: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    marginRight: 8,
  },
  resetButtonText: {
    fontSize: 16,
    color: '#4b5563',
  },
  applyButton: {
    flex: 2,
    paddingVertical: 12,
    alignItems: 'center',
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    marginLeft: 8,
  },
  applyButtonText: {
    fontSize: 16,
    color: '#ffffff',
    fontWeight: '600',
  },
});

export default FilterModal;
===== ./src/components/filters/DateRangeFilter.tsx =====
import React, { useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Modal,
  Platform,
  StyleSheet,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';

interface DateRange {
  startDate: Date | null;
  endDate: Date | null;
}

interface DateRangeFilterProps {
  label?: string;
  value: DateRange;
  onChange: (range: DateRange) => void;
  placeholder?: string;
}

const DateRangeFilter: React.FC<DateRangeFilterProps> = ({
  label = 'Date Range',
  value,
  onChange,
  placeholder = 'Select date range',
}) => {
  const [mode, setMode] = useState<'start' | 'end' | null>(null);
  const [showPicker, setShowPicker] = useState(false);
  const [tempDate, setTempDate] = useState<Date | null>(null);

  // Format date for display
  const formatDate = (date: Date | null): string => {
    if (!date) return '';
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  // Get display text
  const getDisplayText = (): string => {
    if (value.startDate && value.endDate) {
      return `${formatDate(value.startDate)} to ${formatDate(value.endDate)}`;
    } 
    
    if (value.startDate) {
      return `From ${formatDate(value.startDate)}`;
    }
    
    if (value.endDate) {
      return `Until ${formatDate(value.endDate)}`;
    }
    
    return placeholder;
  };

  // Open date picker for start or end date
  const openPicker = (type: 'start' | 'end') => {
    setMode(type);
    setTempDate(
      type === 'start' ? value.startDate || new Date() : value.endDate || new Date()
    );
    setShowPicker(true);
  };

  // Handle date change
  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowPicker(Platform.OS === 'ios');
    
    if (selectedDate) {
      setTempDate(selectedDate);
      
      if (Platform.OS !== 'ios') {
        // On Android, we immediately apply the date when selected
        const newRange = { ...value };
        if (mode === 'start') {
          newRange.startDate = selectedDate;
        } else {
          newRange.endDate = selectedDate;
        }
        onChange(newRange);
      }
    }
  };

  // Clear date range
  const clearDateRange = () => {
    onChange({ startDate: null, endDate: null });
  };

  // Confirm iOS picker
  const confirmIOSPicker = () => {
    if (tempDate) {
      const newRange = { ...value };
      if (mode === 'start') {
        newRange.startDate = tempDate;
      } else {
        newRange.endDate = tempDate;
      }
      onChange(newRange);
    }
    setShowPicker(false);
  };

  // Cancel iOS picker
  const cancelIOSPicker = () => {
    setShowPicker(false);
  };

  // Render iOS picker modal
  const renderIOSPicker = () => (
    <Modal
      transparent={true}
      visible={showPicker && Platform.OS === 'ios'}
      animationType="slide"
    >
      <View style={styles.iosPickerContainer}>
        <View style={styles.iosPickerContent}>
          <View style={styles.iosPickerHeader}>
            <TouchableOpacity onPress={cancelIOSPicker}>
              <Text style={styles.iosPickerCancelText}>Cancel</Text>
            </TouchableOpacity>
            <Text style={styles.iosPickerTitle}>
              Select {mode === 'start' ? 'Start' : 'End'} Date
            </Text>
            <TouchableOpacity onPress={confirmIOSPicker}>
              <Text style={styles.iosPickerDoneText}>Done</Text>
            </TouchableOpacity>
          </View>
          <DateTimePicker
            value={tempDate || new Date()}
            mode="date"
            display="spinner"
            onChange={handleDateChange}
            style={styles.iosPicker}
          />
        </View>
      </View>
    </Modal>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.label}>{label}</Text>

      <View style={styles.dateRangeContainer}>
        <TouchableOpacity
          style={styles.dateButton}
          onPress={() => openPicker('start')}
        >
          <Text
            style={[
              styles.dateButtonText,
              value.startDate ? styles.dateButtonTextSelected : {},
            ]}
          >
            {value.startDate ? formatDate(value.startDate) : 'Start Date'}
          </Text>
        </TouchableOpacity>

        <Text style={styles.dateRangeSeparator}>to</Text>

        <TouchableOpacity
          style={styles.dateButton}
          onPress={() => openPicker('end')}
        >
          <Text
            style={[
              styles.dateButtonText,
              value.endDate ? styles.dateButtonTextSelected : {},
            ]}
          >
            {value.endDate ? formatDate(value.endDate) : 'End Date'}
          </Text>
        </TouchableOpacity>

        {(value.startDate || value.endDate) && (
          <TouchableOpacity
            style={styles.clearButton}
            onPress={clearDateRange}
            hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}
          >
            <Ionicons name="close-circle" size={18} color="#6b7280" />
          </TouchableOpacity>
        )}
      </View>

      {Platform.OS === 'android' && showPicker && (
        <DateTimePicker
          value={tempDate || new Date()}
          mode="date"
          display="default"
          onChange={handleDateChange}
        />
      )}

      {Platform.OS === 'ios' && renderIOSPicker()}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 8,
  },
  dateRangeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    padding: 8,
  },
  dateButton: {
    flex: 1,
    backgroundColor: '#f9fafb',
    borderRadius: 6,
    paddingVertical: 8,
    paddingHorizontal: 12,
    alignItems: 'center',
  },
  dateButtonText: {
    fontSize: 14,
    color: '#9ca3af',
  },
  dateButtonTextSelected: {
    color: '#1f2937',
  },
  dateRangeSeparator: {
    fontSize: 14,
    color: '#6b7280',
    marginHorizontal: 8,
  },
  clearButton: {
    padding: 4,
    marginLeft: 8,
  },
  // iOS specific styles
  iosPickerContainer: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  iosPickerContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    overflow: 'hidden',
  },
  iosPickerHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  iosPickerTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
  },
  iosPickerCancelText: {
    fontSize: 15,
    color: '#6b7280',
  },
  iosPickerDoneText: {
    fontSize: 15,
    color: '#4f46e5',
    fontWeight: '600',
  },
  iosPicker: {
    height: 216,
  },
});

export default DateRangeFilter;
===== ./src/components/filters/OrganisationFilter.tsx =====
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  StyleSheet,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { supabase } from '../../integrations/supabase/client';
import { useDebounce } from '../../hooks/useDebounce';

interface Organisation {
  id: string;
  name: string;
  type: string | null;
}

interface OrganisationFilterProps {
  onSelect: (organisation: Organisation | null) => void;
  selectedOrganisation: Organisation | null;
  label?: string;
}

const OrganisationFilter: React.FC<OrganisationFilterProps> = ({
  onSelect,
  selectedOrganisation,
  label = 'Organisation',
}) => {
  const [searchText, setSearchText] = useState('');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [organisations, setOrganisations] = useState<Organisation[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [organisationTypes, setOrganisationTypes] = useState<string[]>([]);
  const [selectedType, setSelectedType] = useState<string | null>(null);

  // Debounce search to avoid too many requests
  const debouncedSearch = useDebounce(searchText, 300);

  // Fetch organisation types
  useEffect(() => {
    const fetchOrganisationTypes = async () => {
      try {
        const { data, error } = await supabase
          .from('organisation')
          .select('type')
          .not('type', 'is', null);

        if (error) throw error;

        // Extract unique types
        const types = Array.from(
          new Set(data.map((item) => item.type).filter(Boolean))
        ).sort() as string[];

        setOrganisationTypes(types);
      } catch (err) {
        console.error('Error fetching organisation types:', err);
        setError('Failed to load organisation types');
      }
    };

    fetchOrganisationTypes();
  }, []);

  // Fetch organisations based on search and type filter
  const fetchOrganisations = useCallback(async () => {
    if (!isDropdownOpen) return;

    setIsLoading(true);
    setError(null);

    try {
      let query = supabase
        .from('organisation')
        .select('id, name, type')
        .order('name');

      // Apply search filter if text is provided
      if (debouncedSearch) {
        query = query.ilike('name', `%${debouncedSearch}%`);
      }

      // Apply type filter if selected
      if (selectedType) {
        query = query.eq('type', selectedType);
      }

      // Limit results for performance
      query = query.limit(50);

      const { data, error } = await query;

      if (error) throw error;

      setOrganisations(data || []);
    } catch (err) {
      console.error('Error fetching organisations:', err);
      setError('Failed to load organisations');
    } finally {
      setIsLoading(false);
    }
  }, [debouncedSearch, selectedType, isDropdownOpen]);

  // Fetch organisations when search or type changes
  useEffect(() => {
    fetchOrganisations();
  }, [fetchOrganisations]);

  // Handle organisation selection
  const handleSelectOrganisation = (organisation: Organisation) => {
    onSelect(organisation);
    setIsDropdownOpen(false);
    setSearchText('');
  };

  // Clear selection
  const handleClear = () => {
    onSelect(null);
    setSearchText('');
    setSelectedType(null);
  };

  // Toggle dropdown
  const toggleDropdown = () => {
    setIsDropdownOpen(!isDropdownOpen);
    if (!isDropdownOpen) {
      // Reset search when opening
      setSearchText('');
    }
  };

  // Toggle organisation type filter
  const handleSelectType = (type: string) => {
    if (selectedType === type) {
      setSelectedType(null);
    } else {
      setSelectedType(type);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.label}>{label}</Text>

      {/* Selected organisation display or dropdown trigger */}
      <TouchableOpacity 
        style={styles.selectionContainer} 
        onPress={toggleDropdown}
        activeOpacity={0.7}
      >
        {selectedOrganisation ? (
          <View style={styles.selectedOrganisation}>
            <Text style={styles.selectedName}>{selectedOrganisation.name}</Text>
            {selectedOrganisation.type && (
              <Text style={styles.selectedType}>{selectedOrganisation.type}</Text>
            )}
            <TouchableOpacity
              style={styles.clearButton}
              onPress={handleClear}
              hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}
            >
              <Ionicons name="close-circle" size={18} color="#6b7280" />
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.placeholderContainer}>
            <Text style={styles.placeholderText}>Select an organisation</Text>
            <Ionicons name={isDropdownOpen ? "chevron-up" : "chevron-down"} size={18} color="#6b7280" />
          </View>
        )}
      </TouchableOpacity>

      {/* Dropdown content */}
      {isDropdownOpen && (
        <View style={styles.dropdownContainer}>
          {/* Search input */}
          <View style={styles.searchContainer}>
            <Ionicons name="search" size={18} color="#6b7280" style={styles.searchIcon} />
            <TextInput
              style={styles.searchInput}
              placeholder="Search organisations..."
              value={searchText}
              onChangeText={setSearchText}
              autoCapitalize="none"
              autoCorrect={false}
            />
          </View>

          {/* Organisation types filter */}
          {organisationTypes.length > 0 && (
            <View style={styles.typeFiltersContainer}>
              <Text style={styles.typeFiltersTitle}>Filter by type:</Text>
              <View style={styles.typeFiltersScrollContainer}>
                {/* Use FlatList instead of ScrollView for type filters */}
                <FlatList
                  horizontal
                  showsHorizontalScrollIndicator={false}
                  data={organisationTypes}
                  keyExtractor={(item) => item}
                  renderItem={({ item: type }) => (
                    <TouchableOpacity
                      style={[
                        styles.typeFilterChip,
                        selectedType === type && styles.selectedTypeFilterChip,
                      ]}
                      onPress={() => handleSelectType(type)}
                    >
                      <Text
                        style={[
                          styles.typeFilterText,
                          selectedType === type && styles.selectedTypeFilterText,
                        ]}
                      >
                        {type}
                      </Text>
                    </TouchableOpacity>
                  )}
                  contentContainerStyle={styles.typeFilters}
                />
              </View>
            </View>
          )}

          {/* Results container */}
          <View style={styles.resultsContainer}>
            {/* Loading indicator */}
            {isLoading && (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="small" color="#4f46e5" />
                <Text style={styles.loadingText}>Loading organisations...</Text>
              </View>
            )}

            {/* Error message */}
            {error && (
              <View style={styles.errorContainer}>
                <Text style={styles.errorText}>{error}</Text>
              </View>
            )}

            {/* Results list */}
            {!isLoading && !error && (
              <>
                {organisations.length > 0 ? (
                  <FlatList
                    data={organisations}
                    keyExtractor={(item) => item.id}
                    renderItem={({ item }) => (
                      <TouchableOpacity
                        style={styles.organisationItem}
                        onPress={() => handleSelectOrganisation(item)}
                      >
                        <Text style={styles.organisationName}>{item.name}</Text>
                        {item.type && (
                          <Text style={styles.organisationType}>{item.type}</Text>
                        )}
                      </TouchableOpacity>
                    )}
                    style={styles.organisationList}
                    contentContainerStyle={styles.organisationListContent}
                    maxToRenderPerBatch={10}
                    initialNumToRender={10}
                    windowSize={5}
                  />
                ) : (
                  <View style={styles.emptyContainer}>
                    <Text style={styles.emptyText}>No organisations found</Text>
                  </View>
                )}
              </>
            )}
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 8,
  },
  selectionContainer: {
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    padding: 12,
    backgroundColor: '#ffffff',
  },
  selectedOrganisation: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedName: {
    fontSize: 15,
    color: '#1f2937',
    flex: 1,
  },
  selectedType: {
    fontSize: 13,
    color: '#6b7280',
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    marginRight: 8,
  },
  clearButton: {
    padding: 2,
  },
  placeholderContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  placeholderText: {
    fontSize: 15,
    color: '#9ca3af',
  },
  dropdownContainer: {
    marginTop: 8,
    backgroundColor: '#ffffff',
    borderWidth: 1,
    borderColor: '#e5e7eb',
    borderRadius: 8,
    overflow: 'hidden',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    paddingHorizontal: 12,
    paddingVertical: 8,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    fontSize: 14,
    color: '#1f2937',
    paddingVertical: 6,
  },
  typeFiltersContainer: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  typeFiltersTitle: {
    fontSize: 13,
    color: '#6b7280',
    marginBottom: 8,
  },
  typeFiltersScrollContainer: {
    flexDirection: 'row',
  },
  typeFilters: {
    paddingBottom: 4,
  },
  typeFilterChip: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    backgroundColor: '#f3f4f6',
    borderRadius: 16,
    marginRight: 8,
  },
  selectedTypeFilterChip: {
    backgroundColor: '#4f46e5',
  },
  typeFilterText: {
    fontSize: 13,
    color: '#4b5563',
  },
  selectedTypeFilterText: {
    color: '#ffffff',
  },
  resultsContainer: {
    maxHeight: 250,
  },
  loadingContainer: {
    padding: 16,
    alignItems: 'center',
  },
  loadingText: {
    fontSize: 14,
    color: '#6b7280',
    marginTop: 8,
  },
  errorContainer: {
    padding: 16,
    alignItems: 'center',
  },
  errorText: {
    fontSize: 14,
    color: '#ef4444',
    textAlign: 'center',
  },
  organisationList: {
    maxHeight: 216,
  },
  organisationListContent: {
    paddingHorizontal: 12,
  },
  organisationItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  organisationName: {
    fontSize: 14,
    color: '#1f2937',
    flex: 1,
  },
  organisationType: {
    fontSize: 12,
    color: '#6b7280',
    backgroundColor: '#f3f4f6',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
  },
  emptyContainer: {
    padding: 16,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
  },
});

export default OrganisationFilter;
===== ./src/components/GalleryHeader.tsx =====
// GalleryHeader.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';


interface GalleryHeaderProps {
  onFilterPress: () => void;
  viewMode: 'grid' | 'compact' | 'single';
  setViewMode: (mode: 'grid' | 'compact' | 'single') => void;
}

const GalleryHeader = ({ onFilterPress, viewMode, setViewMode }: GalleryHeaderProps) => {
  return (
    <View style={styles.header}>
      <Text style={styles.headerTitle}>Photo Gallery</Text>
      <View style={styles.headerButtons}>
        <TouchableOpacity 
          style={styles.filterButton}
          onPress={onFilterPress}
        >
          <Ionicons name="filter-outline" size={20} color="#4f46e5" />
        </TouchableOpacity>
        <View style={styles.viewModeButtons}>
          <TouchableOpacity 
            style={[
              styles.viewModeButton, 
              viewMode === 'grid' && styles.activeViewModeButton
            ]}
            onPress={() => setViewMode('grid')}
          >
            <Ionicons name="grid-outline" size={20} color={viewMode === 'grid' ? "#4f46e5" : "#6b7280"} />
          </TouchableOpacity>
          <TouchableOpacity 
            style={[
              styles.viewModeButton, 
              viewMode === 'compact' && styles.activeViewModeButton
            ]}
            onPress={() => setViewMode('compact')}
          >
            <Ionicons name="list-outline" size={20} color={viewMode === 'compact' ? "#4f46e5" : "#6b7280"} />
          </TouchableOpacity>
          <TouchableOpacity 
            style={[
              styles.viewModeButton, 
              viewMode === 'single' && styles.activeViewModeButton
            ]}
            onPress={() => setViewMode('single')}
          >
            <Ionicons name="square-outline" size={20} color={viewMode === 'single' ? "#4f46e5" : "#6b7280"} />
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingTop: 8,
    paddingBottom: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  headerButtons: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  filterButton: {
    padding: 8,
    marginRight: 8,
  },
  viewModeButtons: {
    flexDirection: 'row',
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    padding: 4,
  },
  viewModeButton: {
    padding: 6,
    borderRadius: 6,
  },
  activeViewModeButton: {
    backgroundColor: '#ffffff',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 1,
    elevation: 1,
  },
});

export default GalleryHeader;

===== ./src/components/HeaderSection.tsx =====
// HeaderSection.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface HeaderSectionProps {
  onCartPress: () => void;
}

const HeaderSection = ({ onCartPress }: HeaderSectionProps) => {
  return (
    <View style={styles.header}>
      <Text style={styles.title}>TrainPhoto</Text>
      <TouchableOpacity onPress={onCartPress}>
        <Ionicons name="cart" size={24} color="#4f46e5" />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#1f2937',
  },
});

export default HeaderSection;

===== ./src/components/PhotoItem.tsx =====
// src/components/PhotoItem.tsx
import React, { useState, useCallback } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ActivityIndicator } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Image } from 'expo-image';

interface Photo {
  id: string;
  title: string;
  photographer: string;
  price: number;
  imageUrl: string;
  thumbnailUrl?: string; // Make thumbnail optional
  location: string;
  description: string;
}

interface PhotoItemProps {
  photo: Photo;
  viewMode: 'grid' | 'compact' | 'single';
  onPress: (id: string) => void;
}

const PhotoItem = ({ photo, viewMode, onPress }: PhotoItemProps) => {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [retryCount, setRetryCount] = useState(0);

  // Memoize the onPress handler to prevent unnecessary re-renders
  const handlePress = useCallback(() => {
    onPress(photo.id);
  }, [photo.id, onPress]);

  const handleRetry = useCallback(() => {
    setHasError(false);
    setIsLoading(true);
    setRetryCount(prev => prev + 1);
  }, []);

  // Generate a placeholder blurhash-like color based on the photo id
  const placeholderColor = `#${(parseInt(photo.id.replace(/\D/g, ''), 10) % 0xffffff).toString(16).padStart(6, '0')}`;

  const renderImage = (imageStyle: any) => (
    <View style={{ position: 'relative' }}>
      {isLoading && (
        <ActivityIndicator
          style={styles.loader}
          size="small"
          color="#4f46e5"
        />
      )}
      {hasError && !isLoading && (
        <TouchableOpacity style={styles.retryButton} onPress={handleRetry}>
          <Ionicons name="refresh" size={16} color="#fff" />
          <Text style={styles.retryText}>Retry</Text>
        </TouchableOpacity>
      )}
      <Image
        source={{ uri: photo.imageUrl || 'https://via.placeholder.com/150' }}
        style={[imageStyle, hasError && styles.errorImage]}
        contentFit="cover"
        transition={300}
        placeholder={photo.thumbnailUrl}
        placeholderContentFit="cover"
        cachePolicy="memory-disk"
        recyclingKey={`${photo.id}-${retryCount}`} // Helps with image refresh on retry
        onLoadStart={() => setIsLoading(true)}
        onLoad={() => setIsLoading(false)}
        onError={() => {
          console.log(`Image failed to load: ${photo.imageUrl}`);
          setIsLoading(false);
          setHasError(true);
        }}
        // Add placeholder background color when loading
        //backgroundColor={placeholderColor}
      />
    </View>
  );

  if (viewMode === 'grid') {
    return (
      <TouchableOpacity
        style={styles.gridItem}
        onPress={handlePress}
        activeOpacity={0.7} // Better feedback on touch
      >
        {renderImage(styles.gridImage)}
        <View style={styles.gridItemInfo}>
          <Text style={styles.gridItemTitle} numberOfLines={1}>{photo.title}</Text>
          <Text style={styles.gridItemPrice}>${photo.price.toFixed(2)}</Text>
        </View>
      </TouchableOpacity>
    );
  } else if (viewMode === 'compact') {
    return (
      <TouchableOpacity
        style={styles.compactItem}
        onPress={handlePress}
        activeOpacity={0.7}
      >
        {renderImage(styles.compactImage)}
        <View style={styles.compactInfo}>
          <Text style={styles.compactTitle} numberOfLines={1}>{photo.title}</Text>
          <Text style={styles.compactPhotographer}>{photo.photographer}</Text>
          <View style={styles.compactFooter}>
            <Text style={styles.compactPrice}>${photo.price.toFixed(2)}</Text>
            <TouchableOpacity style={styles.compactButton} activeOpacity={0.6}>
              <Ionicons name="add-circle-outline" size={20} color="#4f46e5" />
            </TouchableOpacity>
          </View>
        </View>
      </TouchableOpacity>
    );
  } else {
    return (
      <View style={styles.singleItem}>
        {renderImage(styles.singleImage)}
        <View style={styles.singleInfo}>
          <Text style={styles.singleTitle}>{photo.title}</Text>
          <Text style={styles.singlePhotographer}>By {photo.photographer}</Text>
          {photo.location && <Text style={styles.singleLocation}>{photo.location}</Text>}
          {photo.description && (
            <Text style={styles.singleDescription} numberOfLines={3}>{photo.description}</Text>
          )}
          <View style={styles.singleFooter}>
            <Text style={styles.singlePrice}>${photo.price.toFixed(2)}</Text>
            <View style={styles.singleButtons}>
              <TouchableOpacity
                style={styles.detailButton}
                onPress={handlePress}
                activeOpacity={0.7}
              >
                <Text style={styles.detailButtonText}>Details</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={styles.addButton}
                activeOpacity={0.7}
              >
                <Ionicons name="cart-outline" size={16} color="#ffffff" />
                <Text style={styles.addButtonText}>Add</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </View>
    );
  }
};

const styles = StyleSheet.create({
  // Existing styles...
  gridItem: {
    flex: 1,
    margin: 4,
    borderRadius: 8,
    overflow: 'hidden',
    backgroundColor: '#ffffff',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  gridImage: {
    width: '100%',
    height: 120,
  },
  gridItemInfo: {
    padding: 8,
  },
  gridItemTitle: {
    fontSize: 13,
    fontWeight: '500',
    color: '#374151',
    marginBottom: 4,
  },
  gridItemPrice: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#4f46e5',
  },
  compactItem: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderRadius: 8,
    marginBottom: 8,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  compactImage: {
    width: 80,
    height: 80,
  },
  compactInfo: {
    flex: 1,
    padding: 12,
    justifyContent: 'space-between',
  },
  compactTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1f2937',
  },
  compactPhotographer: {
    fontSize: 12,
    color: '#6b7280',
  },
  compactFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  compactPrice: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#4f46e5',
  },
  compactButton: {
    padding: 4,
  },
  singleItem: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 3,
  },
  singleImage: {
    width: '100%',
    height: 200,
  },
  singleInfo: {
    padding: 16,
  },
  singleTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 4,
  },
  singlePhotographer: {
    fontSize: 14,
    color: '#4b5563',
    fontWeight: '500',
  },
  singleLocation: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 8,
  },
  singleDescription: {
    fontSize: 14,
    color: '#4b5563',
    marginBottom: 16,
    lineHeight: 20,
  },
  singleFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  singlePrice: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  singleButtons: {
    flexDirection: 'row',
  },
  detailButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#f3f4f6',
    marginRight: 8,
  },
  detailButtonText: {
    fontSize: 14,
    color: '#4b5563',
    fontWeight: '600',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#4f46e5',
  },
  addButtonText: {
    fontSize: 14,
    color: '#ffffff',
    fontWeight: '600',
    marginLeft: 4,
  },
  // New styles for loading and error states
  loader: {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: [{ translateX: -12 }, { translateY: -12 }],
  },
  retryButton: {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: [{ translateX: -40 }, { translateY: -15 }],
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    padding: 5,
    borderRadius: 5,
    flexDirection: 'row',
    alignItems: 'center',
  },
  retryText: {
    color: '#fff',
    marginLeft: 5,
    fontSize: 12,
  },
  errorImage: {
    opacity: 0.5,
    backgroundColor: '#f0f0f0',
  },
});

export default React.memo(PhotoItem); // Add memo to prevent unnecessary re-renders

===== ./src/components/PhotoList.tsx =====
// PhotoList.tsx
import React from 'react';
import { FlatList, View } from 'react-native';
import PhotoItem from './PhotoItem';

interface Photo {
  id: string;
  title: string;
  photographer: string;
  price: number;
  imageUrl: string;
  location: string;
  description: string;
}

interface PhotoListProps {
  photos: Photo[];
  viewMode: 'grid' | 'compact' | 'single';
  onPhotoPress: (id: string) => void;
  refreshControl?: React.ReactElement;
  onEndReached?: () => void;
  onEndReachedThreshold?: number;
  ListHeaderComponent?: React.ReactElement;
  ListFooterComponent?: React.ReactElement;
  ListEmptyComponent?: React.ReactElement;
}

const PhotoList: React.FC<PhotoListProps> = ({
  photos,
  viewMode,
  onPhotoPress,
  refreshControl,
  onEndReached,
  onEndReachedThreshold,
  ListHeaderComponent,
  ListFooterComponent,
  ListEmptyComponent,
}) => {
  return (
    <FlatList
      data={photos}
      renderItem={({ item }) => (
        <PhotoItem
          photo={item}
          viewMode={viewMode}
          onPress={onPhotoPress}
        />
      )}
      keyExtractor={item => item.id}
      numColumns={viewMode === 'grid' ? 2 : 1}
      key={viewMode} // Forces re-render when viewMode changes
      refreshControl={refreshControl}
      onEndReached={onEndReached}
      onEndReachedThreshold={onEndReachedThreshold}
      ListHeaderComponent={ListHeaderComponent}
      ListFooterComponent={ListFooterComponent}
      ListEmptyComponent={ListEmptyComponent}
      contentContainerStyle={[
        { padding: viewMode === 'grid' ? 0 : 8 },
        photos.length === 0 && { flexGrow: 1 }
      ]}
    />
  );
};

export default PhotoList;
===== ./src/components/SearchBar.tsx =====
// SearchBar.tsx
import React, { useState, useEffect, useRef } from 'react';
import { View, TextInput, TouchableOpacity, StyleSheet, Keyboard } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface SearchBarProps {
  onSearch: (text: string) => void;
  onClear?: () => void;
  initialValue?: string;
  placeholder?: string;
  autoFocus?: boolean;
  executeOnChange?: boolean; // New prop to control if search executes while typing
}

const SearchBar: React.FC<SearchBarProps> = ({
  onSearch,
  onClear,
  initialValue = '',
  placeholder = 'Search train photos...',
  autoFocus = false,
  executeOnChange = false // Default to false - only search on submit
}) => {
  const [searchText, setSearchText] = useState(initialValue);
  const inputRef = useRef<TextInput>(null);

  // Update internal state when initialValue changes
  useEffect(() => {
    if (initialValue !== searchText) {
      setSearchText(initialValue);
    }
  }, [initialValue]);

  // Handle text change - only execute search if executeOnChange is true
  const handleTextChange = (text: string) => {
    setSearchText(text);
    
    // If text is empty, clear immediately
    if (!text.trim()) {
      if (onClear) {
        onClear();
      } else {
        onSearch('');
      }
      return;
    }
    
    // Only execute search while typing if explicitly enabled
    if (executeOnChange) {
      onSearch(text);
    }
  };

  // Handle submit (pressing enter/search on keyboard or search icon)
  const handleSubmit = () => {
    // Execute search immediately on submit
    if (searchText.trim()) {
      onSearch(searchText);
    }
    Keyboard.dismiss();
  };

  // Handle clear button press
  const handleClear = () => {
    setSearchText('');
    if (onClear) {
      onClear();
    } else {
      onSearch('');
    }
    
    // Focus the input after clearing
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.searchContainer}>
        <TouchableOpacity 
          onPress={handleSubmit}
          style={styles.searchIcon}
        >
          <Ionicons name="search" size={20} color="#6b7280" />
        </TouchableOpacity>
        
        <TextInput
          ref={inputRef}
          style={styles.input}
          placeholder={placeholder}
          value={searchText}
          onChangeText={handleTextChange}
          onSubmitEditing={handleSubmit}
          returnKeyType="search"
          autoFocus={autoFocus}
          clearButtonMode="never" // We'll provide our own clear button
        />
        
        {searchText.length > 0 && (
          <TouchableOpacity 
            onPress={handleClear} 
            style={styles.clearButton}
            activeOpacity={0.6}
            hitSlop={{ top: 10, right: 10, bottom: 10, left: 10 }}
          >
            <Ionicons name="close-circle" size={20} color="#6b7280" />
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#ffffff',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    padding: 8,
    marginRight: 4,
  },
  input: {
    flex: 1,
    height: 40,
    fontSize: 16,
    color: '#1f2937',
  },
  clearButton: {
    padding: 8,
    marginLeft: 4,
  },
});

export default SearchBar;
===== ./src/components/WelcomeSection.tsx =====
// WelcomeSection.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface WelcomeSectionProps {
  onBrowsePress: () => void;
}

const WelcomeSection = ({ onBrowsePress }: WelcomeSectionProps) => {
  return (
    <View style={styles.welcomeSection}>
      <Text style={styles.welcomeTitle}>Premium Train Photography</Text>
      <Text style={styles.welcomeText}>
        Discover our collection of high-quality train photographs from around the world
      </Text>
      <TouchableOpacity 
        style={styles.browseButton}
        onPress={onBrowsePress}
      >
        <Text style={styles.browseButtonText}>Browse Gallery</Text>
        <Ionicons name="arrow-forward" size={16} color="#ffffff" />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  welcomeSection: {
    backgroundColor: '#4f46e5',
    padding: 24,
    borderRadius: 12,
    marginHorizontal: 16,
    marginTop: 12,
    marginBottom: 24,
  },
  welcomeTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 8,
  },
  welcomeText: {
    fontSize: 14,
    color: '#ebebff',
    marginBottom: 16,
  },
  browseButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    alignSelf: 'flex-start',
  },
  browseButtonText: {
    color: '#ffffff',
    fontWeight: '600',
    marginRight: 8,
  },
});

export default WelcomeSection;

===== ./src/context/AuthContext.tsx =====
// AuthContext.tsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { Session, User } from '@supabase/supabase-js';
import { Alert } from 'react-native';

type AuthContextType = {
  user: User | null;
  session: Session | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  isAdmin: boolean;
  userProfile: UserProfile | null;
  login: (email: string, password: string) => Promise<any>;
  register: (name: string, email: string, password: string) => Promise<any>;
  logout: () => Promise<void>;
  updateProfile: (data: Partial<UserProfile>) => Promise<void>;
  changePassword: (currentPassword: string, newPassword: string) => Promise<void>;
  refreshProfile: () => Promise<void>;
};

export type UserProfile = {
  id: string;
  name: string | null;
  avatar_url: string | null;
  created_at: string | null;
  updated_at: string | null;
  orders: any[];
  favorites: any[];
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isAdmin, setIsAdmin] = useState<boolean>(false);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);

  // Fetch user profile from database
  const fetchUserProfile = async (userId: string) => {
    try {
      const { data, error } = await supabase
        .schema('public')
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .maybeSingle();

      if (error) throw error;

      if (data) {
        setUserProfile(data as UserProfile);
      }

      // Check if user is admin
      const { data: roleData, error: roleError } = await supabase
        .schema('public')
        .rpc('is_admin', { user_id: userId });

      if (roleError) throw roleError;

      setIsAdmin(roleData || false);

    } catch (error: any) {
      console.error('Error fetching user profile:', error);
    }
  };

  useEffect(() => {
    // Set up auth state listener FIRST
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, currentSession) => {
        console.log("Auth state changed:", event);
        setSession(currentSession);
        setUser(currentSession?.user ?? null);
        setIsAuthenticated(!!currentSession);

        if (currentSession?.user) {
          fetchUserProfile(currentSession.user.id);
        } else {
          setUserProfile(null);
          setIsAdmin(false);
        }
      }
    );

    // THEN check for existing session
    supabase.auth.getSession().then(({ data: { session: currentSession } }) => {
      console.log("Initial session check:", !!currentSession);
      setSession(currentSession);
      setUser(currentSession?.user ?? null);
      setIsAuthenticated(!!currentSession);

      if (currentSession?.user) {
        fetchUserProfile(currentSession.user.id);
      }

      setIsLoading(false);
    });

    return () => subscription.unsubscribe();
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      });

      if (error) throw error;

      console.log("Login successful:", data);
      return data;
    } catch (error: any) {
      console.error('Error during login:', error);
      Alert.alert("Login Error", error.message);
      throw error;
    }
  };

  const register = async (name: string, email: string, password: string) => {
    try {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            name
          }
        }
      });

      if (error) throw error;

      console.log("Registration successful:", data);

      // If email confirmation is required
      if (data?.user && !data.user.confirmed_at) {
        Alert.alert(
          "Verification Required",
          "Please check your email for a verification link to complete your registration."
        );
      }

      return data;
    } catch (error: any) {
      console.error('Error during registration:', error);
      Alert.alert("Registration Error", error.message);
      throw error;
    }
  };

  const updateProfile = async (profileData: Partial<UserProfile>) => {
    if (!user) {
      Alert.alert("Error", "You must be logged in to update your profile");
      return;
    }

    try {
      const { error } = await supabase
        .from('profiles')
        .update(profileData)
        .eq('id', user.id);
      
      if (error) throw error;

      // Refresh profile data
      await refreshProfile();

      Alert.alert("Success", "Profile updated successfully");
    } catch (error: any) {
      console.error('Error updating profile:', error);
      Alert.alert("Profile Update Error", error.message);
      throw error;
    }
  };

  const changePassword = async (currentPassword: string, newPassword: string) => {
    if (!user || !user.email) {
      Alert.alert("Error", "You must be logged in to change your password");
      return;
    }

    try {
      // First verify the current password by signing in
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: user.email,
        password: currentPassword
      });

      if (signInError) throw signInError;

      // Then update the password
      const { error } = await supabase.auth.updateUser({
        password: newPassword
      });

      if (error) throw error;

      Alert.alert("Success", "Password changed successfully");
    } catch (error: any) {
      console.error('Error changing password:', error);
      Alert.alert("Password Change Error", error.message);
      throw error;
    }
  };

  const refreshProfile = async () => {
    if (!user) return;

    await fetchUserProfile(user.id);
  };

  const logout = async () => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;

      console.log("Logout successful");
    } catch (error: any) {
      console.error('Error during logout:', error);
      Alert.alert("Logout Error", error.message);
      throw error;
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        isAuthenticated,
        isLoading,
        isAdmin,
        userProfile,
        login,
        register,
        logout,
        updateProfile,
        changePassword,
        refreshProfile
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

===== ./src/context/CartContext.tsx =====
import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export interface Photo {
  id: string;
  title: string;
  imageUrl: string;
  price: number;
  photographer: string;
  [key: string]: any; // for other properties
}

export interface CartItem extends Photo {
  quantity: number;
}

interface CartContextType {
  items: CartItem[];
  totalItems: number;
  totalPrice: number;
  addToCart: (photo: Photo) => void;
  removeFromCart: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

export const CartProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {
  const [items, setItems] = useState<CartItem[]>([]);
  
  // Calculate derived values
  const totalItems = items.reduce((total, item) => total + item.quantity, 0);
  const totalPrice = items.reduce((total, item) => total + (item.price * item.quantity), 0);

  // Load cart from AsyncStorage on mount
  useEffect(() => {
    const loadCart = async () => {
      try {
        const storedCart = await AsyncStorage.getItem('cart');
        if (storedCart) {
          setItems(JSON.parse(storedCart));
        }
      } catch (error) {
        console.error('Failed to load cart from storage', error);
      }
    };

    loadCart();
  }, []);

  // Save cart to AsyncStorage whenever it changes
  useEffect(() => {
    const saveCart = async () => {
      try {
        await AsyncStorage.setItem('cart', JSON.stringify(items));
      } catch (error) {
        console.error('Failed to save cart to storage', error);
      }
    };

    saveCart();
  }, [items]);

  // Add item to cart
  const addToCart = (photo: Photo) => {
    setItems(prevItems => {
      // Check if item already exists in cart
      const itemIndex = prevItems.findIndex(item => item.id === photo.id);
      
      if (itemIndex > -1) {
        // If item exists, increase quantity
        const updatedItems = [...prevItems];
        updatedItems[itemIndex] = {
          ...updatedItems[itemIndex],
          quantity: updatedItems[itemIndex].quantity + 1
        };
        return updatedItems;
      } else {
        // If item doesn't exist, add it with quantity 1
        return [...prevItems, { ...photo, quantity: 1 }];
      }
    });
  };

  // Remove item from cart
  const removeFromCart = (id: string) => {
    setItems(prevItems => prevItems.filter(item => item.id !== id));
  };

  // Update item quantity
  const updateQuantity = (id: string, quantity: number) => {
    if (quantity <= 0) {
      removeFromCart(id);
      return;
    }
    
    setItems(prevItems => 
      prevItems.map(item => 
        item.id === id ? { ...item, quantity } : item
      )
    );
  };

  // Clear the cart
  const clearCart = () => {
    setItems([]);
  };

  return (
    <CartContext.Provider
      value={{
        items,
        totalItems,
        totalPrice,
        addToCart,
        removeFromCart,
        updateQuantity,
        clearCart
      }}
    >
      {children}
    </CartContext.Provider>
  );
};

// Custom hook to use the cart context
export const useCart = () => {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

===== ./src/context/FilterContext.tsx =====
import React, { createContext, useContext, useState, useCallback, ReactNode, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { CatalogPhoto } from '@/services/catalogService';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Define types for our filters
export interface Organisation {
  id: string;
  name: string;
  type: string | null;
}

export interface Location {
  id: string;
  name: string;
  country: { id: string; name: string } | null;
}

export interface Photographer {
  id: string;
  name: string;
}

export interface Collection {
  id: string;
  name: string;
  owner: string | null;
}

export interface DateRange {
  startDate: string | null;
  endDate: string | null;
}

// Define the shape of our filter state
export interface FilterState {
  organisation: Organisation | null;
  location: Location | null;
  photographer: Photographer | null;
  collection: Collection | null;
  dateRange: DateRange | null;
  gauge: string | null;
  searchQuery: string;
}

// Define the context interface
interface FilterContextType {
  filters: FilterState;
  setOrganisation: (org: Organisation | null) => void;
  setLocation: (location: Location | null) => void;
  setPhotographer: (photographer: Photographer | null) => void;
  setCollection: (collection: Collection | null) => void;
  setDateRange: (range: DateRange | null) => void;
  setGauge: (gauge: string | null) => void;
  setSearchQuery: (query: string) => void;
  clearAllFilters: () => void;
  applyFilters: (baseQuery: any) => any; // Returns a modified query
  isLoading: boolean;
  error: string | null;
  filteredResults: CatalogPhoto[];
  hasActiveFilters: boolean;
  refreshFilters: () => Promise<void>;
}

// Create the context
const FilterContext = createContext<FilterContextType | undefined>(undefined);

// Initial filter state
const initialFilterState: FilterState = {
  organisation: null,
  location: null,
  photographer: null,
  collection: null,
  dateRange: null,
  gauge: null,
  searchQuery: '',
};

// Helper function to clear catalog cache
export const clearCatalogCache = async () => {
  // Get all AsyncStorage keys
  const keys = await AsyncStorage.getAllKeys();
  
  // Filter for catalog-related cache keys
  const catalogCacheKeys = keys.filter(key => 
    key.startsWith('app_cache_photos_page_') || 
    key.startsWith('app_cache_category_') ||
    key.startsWith('app_cache_photo_')
  );
  
  // Remove these cache entries
  if (catalogCacheKeys.length > 0) {
    console.log(`Clearing ${catalogCacheKeys.length} catalog cache items`);
    await AsyncStorage.multiRemove(catalogCacheKeys);
    return true;
  }
  
  return false;
};

// Provider component
export const FilterProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [filters, setFilters] = useState<FilterState>(initialFilterState);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filteredResults, setFilteredResults] = useState<CatalogPhoto[]>([]);
  const [lastRefreshTime, setLastRefreshTime] = useState(Date.now());

  // Check if any filters are active
  const hasActiveFilters = Boolean(
    filters.organisation ||
    filters.location ||
    filters.photographer ||
    filters.collection ||
    filters.dateRange ||
    filters.gauge ||
    filters.searchQuery
  );

  // Filter setters
  const setOrganisation = (org: Organisation | null) => {
    console.log('Setting organisation filter:', org);
    setFilters((prev) => ({ ...prev, organisation: org }));
  };

  const setLocation = (location: Location | null) => {
    setFilters((prev) => ({ ...prev, location }));
  };

  const setPhotographer = (photographer: Photographer | null) => {
    setFilters((prev) => ({ ...prev, photographer }));
  };

  const setCollection = (collection: Collection | null) => {
    setFilters((prev) => ({ ...prev, collection }));
  };

  const setDateRange = (range: DateRange | null) => {
    setFilters((prev) => ({ ...prev, dateRange: range }));
  };

  const setGauge = (gauge: string | null) => {
    setFilters((prev) => ({ ...prev, gauge }));
  };

  const setSearchQuery = (query: string) => {
    setFilters((prev) => ({ ...prev, searchQuery: query }));
  };

  // Clear all filters
  const clearAllFilters = () => {
    console.log('Clearing all filters');
    setFilters(initialFilterState);
    setFilteredResults([]);
  };

  // Force refresh filters by clearing cache and triggering a re-fetch
  const refreshFilters = async () => {
    try {
      // First, clear the catalog cache to force fresh data
      const cleared = await clearCatalogCache();
      console.log(`Cache cleared: ${cleared}`);
      
      // Then update the lastRefreshTime to trigger a re-fetch
      setLastRefreshTime(Date.now());
      
      console.log('Filters refreshed at:', new Date().toISOString());
      return;
    } catch (err) {
      console.error('Error refreshing filters:', err);
    }
  };

  // Apply filters to a query
  const applyFilters = useCallback((baseQuery: any) => {
    let query = baseQuery;
    console.log('Starting to apply filters to query');

    // Apply organisation filter with better handling
    if (filters.organisation) {
      console.log(`Filtering by organisation: ${JSON.stringify(filters.organisation)}`);
      
      // Use partial matching with wildcards to catch substrings
      query = query.ilike('organisation', `%${filters.organisation.name}%`);
      
      // Log the SQL that would be generated (approximation)
      console.log(`SQL (approx): WHERE organisation ILIKE '%${filters.organisation.name}%'`);
    }

    // Apply location filter
    if (filters.location) {
      console.log(`Filtering by location: ${filters.location.name}`);
      query = query.ilike('location', `%${filters.location.name}%`);
    }

    // Apply photographer filter
    if (filters.photographer) {
      console.log(`Filtering by photographer: ${filters.photographer.name}`);
      query = query.ilike('photographer', `%${filters.photographer.name}%`);
    }

    // Apply collection filter
    if (filters.collection) {
      console.log(`Filtering by collection: ${filters.collection.name}`);
      query = query.ilike('collection', `%${filters.collection.name}%`);
    }

    // Apply date range filter
    if (filters.dateRange) {
      if (filters.dateRange.startDate) {
        console.log(`Filtering by start date: ${filters.dateRange.startDate}`);
        query = query.gte('date_taken', filters.dateRange.startDate);
      }
      if (filters.dateRange.endDate) {
        console.log(`Filtering by end date: ${filters.dateRange.endDate}`);
        query = query.lte('date_taken', filters.dateRange.endDate);
      }
    }

    // Apply gauge filter
    if (filters.gauge) {
      console.log(`Filtering by gauge: ${filters.gauge}`);
      query = query.eq('gauge', filters.gauge);
    }

    // Apply search query
    if (filters.searchQuery) {
      console.log(`Applying search query: ${filters.searchQuery}`);
      query = query.or(
        `description.ilike.%${filters.searchQuery}%,` +
        `category.ilike.%${filters.searchQuery}%,` +
        `photographer.ilike.%${filters.searchQuery}%,` +
        `location.ilike.%${filters.searchQuery}%,` +
        `organisation.ilike.%${filters.searchQuery}%`
      );
    }

    console.log('Finished applying filters to query');
    return query;
  }, [filters]);

  // Execute a filtered query
  const executeFilteredQuery = useCallback(async () => {
    if (!hasActiveFilters) {
      console.log('No active filters, skipping filtered query');
      setFilteredResults([]);
      return;
    }

    console.log('==== EXECUTING FILTERED QUERY ====');
    console.log('Active filters:', JSON.stringify(filters, null, 2));
    setIsLoading(true);
    setError(null);

    try {
      // Start with a base query
      let query = supabase
        .from('mobile_catalog_view')
        .select('*')
        .order('date_taken', { ascending: false });

      // Apply all the filters
      console.log('Applying filters to Supabase query...');
      query = applyFilters(query);
      
      // Limit results for performance
      query = query.limit(50);
      
      console.log('Executing Supabase query');
      const { data, error: queryError } = await query;

      if (queryError) {
        console.error('Supabase query error:', queryError);
        throw queryError;
      }

      // Process and set the results
      const results = data || [];
      console.log(`Query returned ${results.length} results (FRESH DATA)`);
      
      const processedResults = results.map(item => ({
        ...item,
        id: item.image_no, // Ensure id is set for compatibility
        image_url: getImageUrl(item.image_no)
      }));
      
      console.log(`Processed ${processedResults.length} results with image URLs`);
      
      // Log a sample result to help debugging
      if (processedResults.length > 0) {
        console.log('Sample result (first item):', {
          id: processedResults[0].id,
          image_no: processedResults[0].image_no,
          description: processedResults[0].description,
          organisation: processedResults[0].organisation
        });
      }
      
      setFilteredResults(processedResults);

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      console.error('Error executing filtered query:', errorMessage);
      setError(errorMessage);
      setFilteredResults([]);
    } finally {
      setIsLoading(false);
    }
  }, [applyFilters, hasActiveFilters, filters]);

  // Function to generate image URLs (copied from catalogService)
  const getImageUrl = (imageNo: string): string => {
    // Normalize the image_no by removing spaces to match the file name format
    const normalizedImageNo = imageNo.replace(/\s/g, '');
    const url = supabase.storage.from('picaloco').getPublicUrl(`images/${normalizedImageNo}.webp`).data.publicUrl;
    return url;
  };

  // Execute query when filters change
  useEffect(() => {
    executeFilteredQuery();
  }, [executeFilteredQuery, lastRefreshTime]);

  const value = {
    filters,
    setOrganisation,
    setLocation,
    setPhotographer,
    setCollection,
    setDateRange,
    setGauge,
    setSearchQuery,
    clearAllFilters,
    applyFilters,
    isLoading,
    error,
    filteredResults,
    hasActiveFilters,
    refreshFilters
  };

  return (
    <FilterContext.Provider value={value}>
      {children}
    </FilterContext.Provider>
  );
};

// Custom hook for using the filter context
export const useFilters = () => {
  const context = useContext(FilterContext);
  if (context === undefined) {
    throw new Error('useFilters must be used within a FilterProvider');
  }
  return context;
};
===== ./src/hooks/use-mobile.tsx =====
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

===== ./src/hooks/use-toast.ts =====
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

===== ./src/hooks/useDebounce.ts =====
import { useState, useEffect } from 'react';

/**
 * A hook that returns a debounced value after the specified delay.
 * Useful for search inputs to avoid making API calls on every keystroke.
 * 
 * @param value The value to debounce
 * @param delay The delay in milliseconds
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up a timer to update the debounced value after the specified delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer if the value changes before the delay expires
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
===== ./src/hooks/useNetworkStatus.ts =====
// src/hooks/useNetworkStatus.ts
import { useState, useEffect } from 'react';
import NetInfo from '@react-native-community/netinfo';

export const useNetworkStatus = () => {
  const [isConnected, setIsConnected] = useState<boolean | null>(null);
  const [isInternetReachable, setIsInternetReachable] = useState<boolean | null>(null);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected);
      setIsInternetReachable(state.isInternetReachable);
    });

    return () => unsubscribe();
  }, []);

  return {
    isConnected,
    isInternetReachable,
    isOffline: isConnected === false || isInternetReachable === false
  };
};
===== ./src/hooks/usePhotoFilters.ts =====
import { useState, useEffect } from 'react';
import { Photo as CartPhoto } from '@/context/CartContext';
import { Photo as ServicePhoto, PhotoFilters } from '@/services/photoService';
import { filterPhotos } from '@/services/photoService'; 

interface UsePhotoFiltersProps {
  allPhotos: CartPhoto[] | ServicePhoto[];
  minPrice: number;
  maxPrice: number;
}

interface UsePhotoFiltersReturn {
  filters: PhotoFilters;
  setFilters: React.Dispatch<React.SetStateAction<PhotoFilters>>;
  displayPhotos: CartPhoto[] | ServicePhoto[];
  clearFilters: () => void;
  setSortBy: (sortBy: 'newest' | 'popular' | 'price_high' | 'price_low') => void;
}

export const usePhotoFilters = ({
  allPhotos,
  minPrice,
  maxPrice
}: UsePhotoFiltersProps): UsePhotoFiltersReturn => {
  const [filters, setFilters] = useState<PhotoFilters>({
    tags: [],
    photographers: [],
    locations: [],
    priceRange: [minPrice, maxPrice],
    sortBy: 'newest'
  });
  
  const [displayPhotos, setDisplayPhotos] = useState<CartPhoto[] | ServicePhoto[]>(allPhotos);
  
  // Apply filters when they change
  useEffect(() => {
    // Need to cast to ServicePhoto[] since filterPhotos expects that type
    const servicePhotos = allPhotos as ServicePhoto[];
    const filtered = filterPhotos(servicePhotos, filters);
    setDisplayPhotos(filtered);
  }, [filters, allPhotos]);
  
  // Clear all filters
  const clearFilters = () => {
    setFilters({
      tags: [],
      photographers: [],
      locations: [],
      priceRange: [minPrice, maxPrice],
      sortBy: filters.sortBy // Keep the current sort option
    });
  };
  
  // Set sort by option
  const setSortBy = (sortBy: 'newest' | 'popular' | 'price_high' | 'price_low') => {
    setFilters(prev => ({
      ...prev,
      sortBy
    }));
  };
  
  return {
    filters,
    setFilters,
    displayPhotos,
    clearFilters,
    setSortBy
  };
};

===== ./src/hooks/useSearch.ts =====
// src/hooks/useSearch.ts
import { useState, useEffect, useCallback } from 'react';
import { searchPhotos } from '@/services/catalogService';
import { CatalogPhoto } from '@/services/catalogService';

export interface SearchState {
  query: string;
  results: CatalogPhoto[];
  isLoading: boolean;
  isError: boolean;
  errorMessage: string | null;
  hasMore: boolean;
  page: number;
}

export interface UseSearchOptions {
  initialQuery?: string;
  itemsPerPage?: number;
  cacheResults?: boolean;
  cacheDuration?: number; // minutes
}

/**
 * Custom hook for handling search functionality
 */
export const useSearch = (options: UseSearchOptions = {}) => {
  const {
    initialQuery = '',
    itemsPerPage = 10,
    cacheResults = true,
    cacheDuration = 15
  } = options;

  const [state, setState] = useState<SearchState>({
    query: initialQuery,
    results: [],
    isLoading: false,
    isError: false,
    errorMessage: null,
    hasMore: true,
    page: 1
  });

  // Execute search
  const executeSearch = useCallback(async (searchQuery: string, page: number = 1) => {
    if (!searchQuery.trim()) {
      setState(prev => ({
        ...prev,
        query: '',
        results: [],
        isLoading: false,
        isError: false,
        errorMessage: null,
        page: 1
      }));
      return;
    }

    setState(prev => ({
      ...prev,
      isLoading: true,
      isError: false,
      errorMessage: null
    }));

    try {
      // Using the catalogService's searchPhotos function
      const results = await searchPhotos(
        searchQuery, 
        page, 
        itemsPerPage, 
        { useCache: cacheResults, cacheDuration }
      );

      if (page === 1) {
        // New search, replace all results
        setState(prev => ({
          ...prev,
          query: searchQuery,
          results,
          isLoading: false,
          hasMore: results.length >= itemsPerPage,
          page
        }));
      } else {
        // Load more, append to existing results
        setState(prev => ({
          ...prev,
          results: [...prev.results, ...results],
          isLoading: false,
          hasMore: results.length >= itemsPerPage,
          page
        }));
      }
    } catch (error) {
      console.error('Search error:', error);
      setState(prev => ({
        ...prev,
        isLoading: false,
        isError: true,
        errorMessage: error instanceof Error ? error.message : 'An unknown error occurred'
      }));
    }
  }, [itemsPerPage, cacheResults, cacheDuration]);

  // Set search query and execute search
  const setSearchQuery = useCallback((query: string) => {
    if (query === state.query) return;
    executeSearch(query, 1);
  }, [state.query, executeSearch]);

  // Load more results (pagination)
  const loadMore = useCallback(() => {
    if (!state.hasMore || state.isLoading) return;
    executeSearch(state.query, state.page + 1);
  }, [state.hasMore, state.isLoading, state.query, state.page, executeSearch]);

  // Clear search
  const clearSearch = useCallback(() => {
    setState({
      query: '',
      results: [],
      isLoading: false,
      isError: false,
      errorMessage: null,
      hasMore: true,
      page: 1
    });
  }, []);

  // Initialize with initial query if provided
  useEffect(() => {
    if (initialQuery) {
      executeSearch(initialQuery, 1);
    }
  }, [initialQuery, executeSearch]);

  return {
    ...state,
    setSearchQuery,
    loadMore,
    clearSearch
  };
};
===== ./src/integrations/supabase/client.ts =====
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

console.log("Supabase URL:", process.env.EXPO_PUBLIC_SUPABASE_URL);
console.log("Supabase Key:", process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY);

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Supabase configuration error: Missing EXPO_PUBLIC_SUPABASE_URL or EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.');
}

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  db: { schema: 'dev' } // Set default schema to dev
});

//export const supabase = createClient<Database>(supabaseUrl, supabaseKey); // No schema specified
===== ./src/integrations/supabase/types.ts =====
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      profiles: {
        Row: {
          avatar_url: string | null
          created_at: string | null
          id: string
          name: string | null
          updated_at: string | null
        }
        Insert: {
          avatar_url?: string | null
          created_at?: string | null
          id: string
          name?: string | null
          updated_at?: string | null
        }
        Update: {
          avatar_url?: string | null
          created_at?: string | null
          id?: string
          name?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
      user_roles: {
        Row: {
          created_at: string | null
          id: string
          role: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          role: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          role?: string
          user_id?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      is_admin: {
        Args: {
          user_id: string
        }
        Returns: boolean
      }
      total_size_in_bucket: {
        Args: {
          bucket_name: string
          bucket_prefix: string
        }
        Returns: number
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof PublicSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema["CompositeTypes"]
    ? PublicSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

===== ./src/lib/utils.ts =====
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

===== ./src/screens/AdminScreen.tsx =====

// AdminScreen.tsx
import React, { useState, useEffect } from 'react';
import { 
  View, Text, StyleSheet, TouchableOpacity, 
  TextInput, ScrollView, Switch, Alert, ActivityIndicator,
  Modal, FlatList
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/context/AuthContext';
import { fetchCategories } from '@/services/catalogService';

const AdminScreen = ({ navigation }) => {
  // Check if user is admin
  const { isAdmin } = useAuth();
  
  // Loading state
  const [isLoading, setIsLoading] = useState(false);
  
  // Tabs state
  const [activeTab, setActiveTab] = useState('settings');
  
  // Category management
  const [categories, setCategories] = useState<string[]>([]);
  const [newCategory, setNewCategory] = useState('');
  const [editCategoryModal, setEditCategoryModal] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState('');
  const [editedCategory, setEditedCategory] = useState('');
  
  // User management
  const [users, setUsers] = useState<any[]>([]);
  
  // Load categories
  useEffect(() => {
    if (activeTab === 'content') {
      loadCategories();
    } else if (activeTab === 'users') {
      loadUsers();
    }
  }, [activeTab]);
  
  const loadCategories = async () => {
    try {
      setIsLoading(true);
      const categories = await fetchCategories();
      setCategories(categories);
    } catch (error) {
      console.error('Error loading categories:', error);
      Alert.alert('Error', 'Failed to load categories');
    } finally {
      setIsLoading(false);
    }
  };
  
  const loadUsers = async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase
        .from('profiles')
        .select('id, name, created_at');
      
      if (error) throw error;
      
      // Get admin status for each user
      const usersWithRoles = await Promise.all(
        (data || []).map(async (user) => {
          const { data: isAdminData } = await supabase
            .rpc('is_admin', { user_id: user.id });
          
          return {
            ...user,
            isAdmin: isAdminData || false
          };
        })
      );
      
      setUsers(usersWithRoles);
    } catch (error) {
      console.error('Error loading users:', error);
      Alert.alert('Error', 'Failed to load users');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleToggleAdmin = async (userId: string, currentStatus: boolean) => {
    try {
      setIsLoading(true);
      
      if (currentStatus) {
        // Remove admin role
        const { error } = await supabase
          .from('user_roles')
          .delete()
          .eq('user_id', userId)
          .eq('role', 'admin');
        
        if (error) throw error;
      } else {
        // Add admin role
        const { error } = await supabase
          .from('user_roles')
          .insert({ user_id: userId, role: 'admin' });
        
        if (error) throw error;
      }
      
      // Refresh user list
      await loadUsers();
      
    } catch (error) {
      console.error('Error toggling admin status:', error);
      Alert.alert('Error', 'Failed to update user role');
    } finally {
      setIsLoading(false);
    }
  };
  
  if (!isAdmin) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={24} color="#374151" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Admin Panel</Text>
          <View style={{ width: 24 }} />
        </View>
        
        <View style={styles.unauthorizedContainer}>
          <Ionicons name="lock-closed" size={48} color="#d1d5db" />
          <Text style={styles.unauthorizedText}>You do not have permission to access this area</Text>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Text style={styles.backButtonText}>Go Back</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }
  
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#374151" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Admin Panel</Text>
        <View style={{ width: 24 }} />
      </View>
      
      {/* Tabs */}
      <View style={styles.tabsContainer}>
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'settings' && styles.activeTab]}
          onPress={() => setActiveTab('settings')}
        >
          <Ionicons 
            name="settings-outline" 
            size={18} 
            color={activeTab === 'settings' ? "#4f46e5" : "#6b7280"} 
          />
          <Text 
            style={[
              styles.tabText, 
              activeTab === 'settings' && styles.activeTabText
            ]}
          >
            Settings
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'users' && styles.activeTab]}
          onPress={() => setActiveTab('users')}
        >
          <Ionicons 
            name="people-outline" 
            size={18} 
            color={activeTab === 'users' ? "#4f46e5" : "#6b7280"} 
          />
          <Text 
            style={[
              styles.tabText, 
              activeTab === 'users' && styles.activeTabText
            ]}
          >
            Users
          </Text>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'content' && styles.activeTab]}
          onPress={() => setActiveTab('content')}
        >
          <Ionicons 
            name="images-outline" 
            size={18} 
            color={activeTab === 'content' ? "#4f46e5" : "#6b7280"} 
          />
          <Text 
            style={[
              styles.tabText, 
              activeTab === 'content' && styles.activeTabText
            ]}
          >
            Content
          </Text>
        </TouchableOpacity>
      </View>
      
      <ScrollView contentContainerStyle={styles.content}>
        {isLoading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#4f46e5" />
            <Text style={styles.loadingText}>Loading...</Text>
          </View>
        )}
        
        {!isLoading && activeTab === 'settings' && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Supabase Configuration</Text>
            <Text style={styles.infoText}>Manage application settings and configurations.</Text>
            
            <TouchableOpacity style={styles.settingsItem}>
              <View style={styles.settingInfo}>
                <Text style={styles.settingTitle}>Storage Settings</Text>
                <Text style={styles.settingDescription}>Manage storage buckets and permissions</Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.settingsItem}>
              <View style={styles.settingInfo}>
                <Text style={styles.settingTitle}>API Keys</Text>
                <Text style={styles.settingDescription}>View and manage API keys</Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.settingsItem}>
              <View style={styles.settingInfo}>
                <Text style={styles.settingTitle}>Database Settings</Text>
                <Text style={styles.settingDescription}>Configure database settings</Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
          </View>
        )}
        
        {!isLoading && activeTab === 'users' && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>User Management</Text>
            <Text style={styles.infoText}>Manage user accounts and permissions.</Text>
            
            {users.length > 0 ? (
              <FlatList
                data={users}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                  <View style={styles.userItem}>
                    <View style={styles.userInfo}>
                      <Text style={styles.userName}>{item.name || 'User'}</Text>
                      <Text style={styles.userDate}>
                        Joined {new Date(item.created_at).toLocaleDateString()}
                      </Text>
                    </View>
                    <View style={styles.userActions}>
                      <Text style={styles.roleLabel}>Admin</Text>
                      <Switch
                        value={item.isAdmin}
                        onValueChange={() => handleToggleAdmin(item.id, item.isAdmin)}
                        trackColor={{ false: '#d1d5db', true: '#4f46e5' }}
                        thumbColor="#ffffff"
                      />
                    </View>
                  </View>
                )}
                contentContainerStyle={styles.usersList}
              />
            ) : (
              <Text style={styles.emptyListText}>No users found</Text>
            )}
          </View>
        )}
        
        {!isLoading && activeTab === 'content' && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Category Management</Text>
            <Text style={styles.infoText}>Manage photo categories for the application.</Text>
            
            <View style={styles.addCategoryContainer}>
              <TextInput
                style={styles.categoryInput}
                value={newCategory}
                onChangeText={setNewCategory}
                placeholder="New category name"
              />
              <TouchableOpacity
                style={styles.addButton}
                onPress={() => {
                  Alert.alert(
                    "Add Category",
                    "This would add a new category. This feature requires direct database access.",
                    [{ text: "OK" }]
                  );
                }}
              >
                <Text style={styles.addButtonText}>Add</Text>
              </TouchableOpacity>
            </View>
            
            {categories.length > 0 ? (
              <FlatList
                data={categories}
                keyExtractor={(item) => item}
                renderItem={({ item }) => (
                  <View style={styles.categoryItem}>
                    <Text style={styles.categoryName}>{item}</Text>
                    <View style={styles.categoryActions}>
                      <TouchableOpacity
                        style={styles.editButton}
                        onPress={() => {
                          setSelectedCategory(item);
                          setEditedCategory(item);
                          setEditCategoryModal(true);
                        }}
                      >
                        <Ionicons name="create-outline" size={18} color="#4f46e5" />
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={styles.deleteButton}
                        onPress={() => {
                          Alert.alert(
                            "Delete Category",
                            "Are you sure you want to delete this category?",
                            [
                              { text: "Cancel", style: "cancel" },
                              {
                                text: "Delete",
                                style: "destructive",
                                onPress: () => {
                                  Alert.alert(
                                    "Delete Category",
                                    "This would delete the category. This feature requires direct database access.",
                                    [{ text: "OK" }]
                                  );
                                }
                              }
                            ]
                          );
                        }}
                      >
                        <Ionicons name="trash-outline" size={18} color="#ef4444" />
                      </TouchableOpacity>
                    </View>
                  </View>
                )}
                contentContainerStyle={styles.categoriesList}
              />
            ) : (
              <Text style={styles.emptyListText}>No categories found</Text>
            )}
          </View>
        )}
      </ScrollView>
      
      {/* Edit Category Modal */}
      <Modal
        visible={editCategoryModal}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setEditCategoryModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Edit Category</Text>
              <TouchableOpacity onPress={() => setEditCategoryModal(false)}>
                <Ionicons name="close" size={24} color="#4b5563" />
              </TouchableOpacity>
            </View>
            
            <View style={styles.modalContent}>
              <View style={styles.formGroup}>
                <Text style={styles.label}>Category Name</Text>
                <TextInput
                  style={styles.input}
                  value={editedCategory}
                  onChangeText={setEditedCategory}
                  placeholder="Category name"
                />
              </View>
              
              <TouchableOpacity
                style={styles.saveButton}
                onPress={() => {
                  Alert.alert(
                    "Edit Category",
                    "This would edit the category. This feature requires direct database access.",
                    [
                      { text: "OK", onPress: () => setEditCategoryModal(false) }
                    ]
                  );
                }}
              >
                <Text style={styles.saveButtonText}>Save Changes</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  tabsContainer: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    paddingHorizontal: 4,
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  tab: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    marginHorizontal: 4,
    borderRadius: 8,
  },
  activeTab: {
    backgroundColor: '#ebe9fe',
  },
  tabText: {
    fontSize: 13,
    color: '#6b7280',
    marginLeft: 4,
  },
  activeTabText: {
    color: '#4f46e5',
    fontWeight: '500',
  },
  content: {
    padding: 16,
    paddingBottom: 40,
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#6b7280',
  },
  section: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
    marginBottom: 6,
  },
  infoText: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 16,
  },
  settingsItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
  },
  settingInfo: {
    flex: 1,
  },
  settingTitle: {
    fontSize: 15,
    fontWeight: '500',
    color: '#374151',
  },
  settingDescription: {
    fontSize: 13,
    color: '#6b7280',
    marginTop: 2,
  },
  
  // User management styles
  usersList: {
    paddingTop: 8,
  },
  userItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 15,
    fontWeight: '500',
    color: '#374151',
  },
  userDate: {
    fontSize: 13,
    color: '#6b7280',
  },
  userActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  roleLabel: {
    fontSize: 14,
    color: '#4b5563',
    marginRight: 8,
  },
  
  // Category management styles
  addCategoryContainer: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  categoryInput: {
    flex: 1,
    backgroundColor: '#f9fafb',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 14,
    marginRight: 8,
  },
  addButton: {
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 10,
    justifyContent: 'center',
  },
  addButtonText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '500',
  },
  categoriesList: {
    paddingTop: 8,
  },
  categoryItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
  },
  categoryName: {
    fontSize: 15,
    color: '#374151',
    flex: 1,
  },
  categoryActions: {
    flexDirection: 'row',
  },
  editButton: {
    padding: 6,
    marginRight: 8,
  },
  deleteButton: {
    padding: 6,
  },
  emptyListText: {
    textAlign: 'center',
    color: '#6b7280',
    fontSize: 15,
    marginTop: 16,
    fontStyle: 'italic',
  },
  
  // Unauthorized screen
  unauthorizedContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  unauthorizedText: {
    fontSize: 16,
    color: '#4b5563',
    textAlign: 'center',
    marginTop: 16,
    marginBottom: 24,
  },
  backButton: {
    backgroundColor: '#4f46e5',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  backButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '500',
  },
  
  // Modal styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    width: '100%',
    maxWidth: 500,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  modalContent: {
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#4b5563',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f9fafb',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  saveButton: {
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 8,
  },
  saveButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default AdminScreen;

===== ./src/screens/AuthScreen.tsx =====
// AuthScreen.tsx
import React, { useState } from 'react';
import { 
  View, Text, StyleSheet, TextInput, 
  TouchableOpacity, Image, Alert, KeyboardAvoidingView, 
  Platform, ScrollView, ActivityIndicator 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../context/AuthContext';
import { supabase } from '@/integrations/supabase/client';

const AuthScreen = () => {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  const { login, register } = useAuth();
  
  const handleAuth = async () => {
    if (!email || !password) {
      Alert.alert("Error", "Please fill in all required fields");
      return;
    }
    
    if (!isLogin && password !== confirmPassword) {
      Alert.alert("Error", "Passwords do not match");
      return;
    }
    
    if (!isLogin && !name) {
      Alert.alert("Error", "Please enter your name");
      return;
    }

    setIsLoading(true);
    
    try {
      if (isLogin) {
        await login(email, password);
      } else {
        await register(name, email, password);
        // Registration was successful, but might require email verification
        Alert.alert(
          "Registration Successful", 
          "Your account has been created. You may need to verify your email before logging in."
        );
        setIsLogin(true);
      }
    } catch (error: any) {
      Alert.alert("Authentication Error", error.message);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleGoogleAuth = () => {
    Alert.alert("Coming Soon", "Google authentication will be available soon");
  };
  
  const handleForgotPassword = async () => {
    if (!email) {
      Alert.alert("Error", "Please enter your email address");
      return;
    }
    
    setIsLoading(true);
    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email);
      
      if (error) throw error;
      
      Alert.alert(
        "Password Reset",
        `A password reset link has been sent to ${email}`
      );
    } catch (error: any) {
      Alert.alert("Error", error.message);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoidingView}
      >
        <ScrollView contentContainerStyle={styles.scrollContent}>
          {/* Logo and Header */}
          <View style={styles.header}>
            <Image 
              source={{ uri: 'https://images.unsplash.com/photo-1527684651001-731c474bbb5a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80' }}
              style={styles.logo}
            />
            <Text style={styles.appName}>TrainPhoto</Text>
            <Text style={styles.tagline}>Premium Train Photography Platform</Text>
          </View>
          
          {/* Auth Form */}
          <View style={styles.formContainer}>
            <Text style={styles.formTitle}>
              {isLogin ? 'Log in to your account' : 'Create your account'}
            </Text>
            
            {!isLogin && (
              <View style={styles.inputGroup}>
                <Text style={styles.label}>Name</Text>
                <View style={styles.inputWrapper}>
                  <Ionicons name="person-outline" size={20} color="#9ca3af" style={styles.inputIcon} />
                  <TextInput
                    style={styles.input}
                    placeholder="Your full name"
                    value={name}
                    onChangeText={setName}
                  />
                </View>
              </View>
            )}
            
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Email</Text>
              <View style={styles.inputWrapper}>
                <Ionicons name="mail-outline" size={20} color="#9ca3af" style={styles.inputIcon} />
                <TextInput
                  style={styles.input}
                  placeholder="your.email@example.com"
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                />
              </View>
            </View>
            
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Password</Text>
              <View style={styles.inputWrapper}>
                <Ionicons name="lock-closed-outline" size={20} color="#9ca3af" style={styles.inputIcon} />
                <TextInput
                  style={styles.input}
                  placeholder="Your password"
                  value={password}
                  onChangeText={setPassword}
                  secureTextEntry={!showPassword}
                />
                <TouchableOpacity
                  style={styles.eyeIcon}
                  onPress={() => setShowPassword(!showPassword)}
                >
                  <Ionicons 
                    name={showPassword ? "eye-off-outline" : "eye-outline"} 
                    size={20} 
                    color="#9ca3af" 
                  />
                </TouchableOpacity>
              </View>
            </View>
            
            {!isLogin && (
              <View style={styles.inputGroup}>
                <Text style={styles.label}>Confirm Password</Text>
                <View style={styles.inputWrapper}>
                  <Ionicons name="lock-closed-outline" size={20} color="#9ca3af" style={styles.inputIcon} />
                  <TextInput
                    style={styles.input}
                    placeholder="Confirm your password"
                    value={confirmPassword}
                    onChangeText={setConfirmPassword}
                    secureTextEntry={!showPassword}
                  />
                </View>
              </View>
            )}
            
            {isLogin && (
              <TouchableOpacity
                style={styles.forgotPassword}
                onPress={handleForgotPassword}
              >
                <Text style={styles.forgotPasswordText}>Forgot password?</Text>
              </TouchableOpacity>
            )}
            
            <TouchableOpacity
              style={[styles.authButton, isLoading && styles.authButtonDisabled]}
              onPress={handleAuth}
              disabled={isLoading}
            >
              {isLoading ? (
                <ActivityIndicator color="#ffffff" />
              ) : (
                <Text style={styles.authButtonText}>
                  {isLogin ? 'Log in' : 'Sign up'}
                </Text>
              )}
            </TouchableOpacity>
            
            <View style={styles.dividerContainer}>
              <View style={styles.divider} />
              <Text style={styles.dividerText}>or</Text>
              <View style={styles.divider} />
            </View>
            
            <TouchableOpacity
              style={styles.googleButton}
              onPress={handleGoogleAuth}
            >
              <Ionicons name="logo-google" size={20} color="#4285F4" />
              <Text style={styles.googleButtonText}>
                {isLogin ? 'Log in with Google' : 'Sign up with Google'}
              </Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={styles.switchMode}
              onPress={() => {
                setIsLogin(!isLogin);
                setPassword('');
                setConfirmPassword('');
              }}
            >
              <Text style={styles.switchModeText}>
                {isLogin 
                  ? "Don't have an account? Sign up" 
                  : "Already have an account? Log in"}
              </Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    paddingBottom: 24,
  },
  header: {
    alignItems: 'center',
    paddingTop: 40,
    paddingBottom: 24,
  },
  logo: {
    width: 80,
    height: 80,
    borderRadius: 16,
    marginBottom: 16,
  },
  appName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 4,
  },
  tagline: {
    fontSize: 14,
    color: '#6b7280',
  },
  formContainer: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 24,
    flex: 1,
  },
  formTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 24,
    textAlign: 'center',
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#4b5563',
    marginBottom: 6,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    backgroundColor: '#f9fafb',
  },
  inputIcon: {
    paddingHorizontal: 12,
  },
  input: {
    flex: 1,
    paddingVertical: 12,
    fontSize: 14,
    color: '#1f2937',
  },
  eyeIcon: {
    padding: 12,
  },
  forgotPassword: {
    alignSelf: 'flex-end',
    marginBottom: 24,
  },
  forgotPasswordText: {
    fontSize: 14,
    color: '#4f46e5',
  },
  authButton: {
    backgroundColor: '#4f46e5',
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 16,
  },
  authButtonDisabled: {
    backgroundColor: '#a5b4fc',
  },
  authButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 16,
  },
  divider: {
    flex: 1,
    height: 1,
    backgroundColor: '#e5e7eb',
  },
  dividerText: {
    paddingHorizontal: 16,
    fontSize: 14,
    color: '#6b7280',
  },
  googleButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#d1d5db',
    marginBottom: 24,
  },
  googleButtonText: {
    fontSize: 16,
    color: '#4b5563',
    marginLeft: 8,
  },
  switchMode: {
    alignItems: 'center',
  },
  switchModeText: {
    fontSize: 14,
    color: '#4f46e5',
  },
});

export default AuthScreen;

===== ./src/screens/CartScreen.tsx =====
// CartScreen.tsx
import React from 'react';
import { 
  View, Text, StyleSheet, FlatList, Image, 
  TouchableOpacity, Alert 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';

// These would come from the CartContext in a real implementation
const cartItems = [
  {
    id: 'photo1',
    title: 'Vintage Steam Locomotive',
    photographer: 'John Smith',
    price: 49.99,
    quantity: 1,
    imageUrl: 'https://images.unsplash.com/photo-1527684651001-731c474bbb5a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80',
  },
  {
    id: 'photo2',
    title: 'Modern High-Speed Train',
    photographer: 'Sarah Johnson',
    price: 39.99,
    quantity: 2,
    imageUrl: 'https://images.unsplash.com/photo-1679679008383-6f778fe07382?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80',
  },
];

const CartScreen = ({ navigation }) => {
  // Calculate total price
  const totalPrice = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  
  const handleRemoveItem = (id: string) => {
    Alert.alert(
      "Remove Item",
      "Are you sure you want to remove this item from your cart?",
      [
        {
          text: "Cancel",
          style: "cancel"
        },
        { 
          text: "Remove", 
          style: "destructive",
          // In a real app, we would call removeFromCart here
          onPress: () => console.log("Remove item:", id) 
        }
      ]
    );
  };
  
  const handleUpdateQuantity = (id: string, newQuantity: number) => {
    // In a real app, we would call updateQuantity here
    console.log("Update quantity for", id, "to", newQuantity);
  };
  
  const handleCheckout = () => {
    Alert.alert(
      "Checkout",
      "This would proceed to payment in a real app.",
      [{ text: "OK" }]
    );
  };
  
  const renderCartItem = ({ item }) => (
    <View style={styles.cartItem}>
      <TouchableOpacity
        onPress={() => navigation.navigate('PhotoDetail', { id: item.id })}
      >
        <Image 
          source={{ uri: item.imageUrl }}
          style={styles.itemImage}
          resizeMode="cover"
        />
      </TouchableOpacity>
      
      <View style={styles.itemDetails}>
        <TouchableOpacity
          onPress={() => navigation.navigate('PhotoDetail', { id: item.id })}
        >
          <Text style={styles.itemTitle} numberOfLines={1}>{item.title}</Text>
        </TouchableOpacity>
        <Text style={styles.itemPhotographer}>{item.photographer}</Text>
        
        <View style={styles.priceRow}>
          <Text style={styles.itemPrice}>${item.price.toFixed(2)}</Text>
          
          <View style={styles.quantityControls}>
            <TouchableOpacity
              style={styles.quantityButton}
              onPress={() => {
                if (item.quantity > 1) {
                  handleUpdateQuantity(item.id, item.quantity - 1);
                } else {
                  handleRemoveItem(item.id);
                }
              }}
            >
              <Ionicons name="remove" size={16} color="#4b5563" />
            </TouchableOpacity>
            
            <Text style={styles.quantityText}>{item.quantity}</Text>
            
            <TouchableOpacity
              style={styles.quantityButton}
              onPress={() => handleUpdateQuantity(item.id, item.quantity + 1)}
            >
              <Ionicons name="add" size={16} color="#4b5563" />
            </TouchableOpacity>
          </View>
        </View>
        
        <Text style={styles.itemTotal}>
          Total: ${(item.price * item.quantity).toFixed(2)}
        </Text>
      </View>
      
      <TouchableOpacity
        style={styles.removeButton}
        onPress={() => handleRemoveItem(item.id)}
      >
        <Ionicons name="trash-outline" size={18} color="#ef4444" />
      </TouchableOpacity>
    </View>
  );
  
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Shopping Cart</Text>
        {cartItems.length > 0 && (
          <TouchableOpacity
            onPress={() => Alert.alert(
              "Clear Cart",
              "Are you sure you want to remove all items from your cart?",
              [
                {
                  text: "Cancel",
                  style: "cancel"
                },
                { 
                  text: "Clear", 
                  style: "destructive",
                  // In a real app, we would call clearCart here
                  onPress: () => console.log("Clear cart") 
                }
              ]
            )}
          >
            <Text style={styles.clearCartText}>Clear Cart</Text>
          </TouchableOpacity>
        )}
      </View>
      
      {cartItems.length > 0 ? (
        <>
          <FlatList
            data={cartItems}
            renderItem={renderCartItem}
            keyExtractor={item => item.id}
            contentContainerStyle={styles.cartList}
          />
          
          <View style={styles.summaryContainer}>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryLabel}>Subtotal</Text>
              <Text style={styles.summaryValue}>${totalPrice.toFixed(2)}</Text>
            </View>
            
            <View style={styles.summaryRow}>
              <Text style={styles.summaryLabel}>Tax</Text>
              <Text style={styles.summaryValue}>${(totalPrice * 0.08).toFixed(2)}</Text>
            </View>
            
            <View style={styles.divider} />
            
            <View style={styles.totalRow}>
              <Text style={styles.totalLabel}>Total</Text>
              <Text style={styles.totalValue}>
                ${(totalPrice * 1.08).toFixed(2)}
              </Text>
            </View>
            
            <TouchableOpacity
              style={styles.checkoutButton}
              onPress={handleCheckout}
            >
              <Text style={styles.checkoutButtonText}>Proceed to Checkout</Text>
              <Ionicons name="arrow-forward" size={16} color="#ffffff" />
            </TouchableOpacity>
          </View>
        </>
      ) : (
        <View style={styles.emptyCartContainer}>
          <Ionicons name="cart-outline" size={64} color="#d1d5db" />
          <Text style={styles.emptyCartTitle}>Your cart is empty</Text>
          <Text style={styles.emptyCartMessage}>
            Add some beautiful train photos to your cart
          </Text>
          <TouchableOpacity
            style={styles.browseButton}
            onPress={() => navigation.navigate('Gallery')}
          >
            <Text style={styles.browseButtonText}>Browse Photos</Text>
          </TouchableOpacity>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  clearCartText: {
    fontSize: 14,
    color: '#dc2626',
  },
  cartList: {
    padding: 16,
  },
  cartItem: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  itemImage: {
    width: 80,
    height: 80,
    borderRadius: 4,
  },
  itemDetails: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'space-between',
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
  },
  itemPhotographer: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 4,
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 4,
  },
  itemPrice: {
    fontSize: 15,
    fontWeight: '500',
    color: '#1f2937',
  },
  quantityControls: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  quantityButton: {
    width: 24,
    height: 24,
    borderRadius: 4,
    backgroundColor: '#f3f4f6',
    justifyContent: 'center',
    alignItems: 'center',
  },
  quantityText: {
    fontSize: 14,
    fontWeight: '500',
    paddingHorizontal: 8,
  },
  itemTotal: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4f46e5',
    marginTop: 4,
  },
  removeButton: {
    padding: 8,
  },
  summaryContainer: {
    backgroundColor: '#ffffff',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  summaryLabel: {
    fontSize: 14,
    color: '#4b5563',
  },
  summaryValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#1f2937',
  },
  divider: {
    height: 1,
    backgroundColor: '#e5e7eb',
    marginVertical: 12,
  },
  totalRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
  },
  totalValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  checkoutButton: {
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    paddingVertical: 14,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  checkoutButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
    marginRight: 8,
  },
  emptyCartContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  emptyCartTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyCartMessage: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 24,
  },
  browseButton: {
    backgroundColor: '#4f46e5',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  browseButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default CartScreen;

===== ./src/screens/GalleryScreen.tsx =====
// GalleryScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { 
  SafeAreaView, 
  StyleSheet, 
  View, 
  ActivityIndicator, 
  Text, 
  RefreshControl,
  TouchableOpacity
} from 'react-native';
import { useFocusEffect } from '@react-navigation/native';

// Import components
import GalleryHeader from '../components/GalleryHeader';
import CategoryFilter from '../components/CategoryFilter';
import AdvancedFilterModal from '../components/AdvancedFilterModal';
import PhotoList from '../components/PhotoList';
import SearchBar from '../components/SearchBar';
import FilterDebugger from '../components/FilterDebugger';

// Import services and hooks
import { 
  fetchCatalogPhotos, 
  fetchPhotosByCategory,
  fetchCategories,
  CatalogPhoto 
} from '../services/catalogService';
import { useSearch } from '../hooks/useSearch';
import { useNetworkStatus } from '../hooks/useNetworkStatus';
import { FilterProvider, useFilters } from '../context/FilterContext';

const GalleryScreen = ({ navigation, route }) => {
  // Extract params from route
  const initialCategory = route.params?.category || 'all';
  const initialSearchQuery = route.params?.searchQuery || '';
  const fromSearch = route.params?.fromSearch || false;

  // Extract filter context at top level (Correctly following Rules of Hooks)
  const { 
    filteredResults, 
    hasActiveFilters,
    clearAllFilters,
    refreshFilters,
    isLoading: isFilterLoading,
    error: filterError
  } = useFilters();

  // State
  const [viewMode, setViewMode] = useState<'grid' | 'compact' | 'single'>('grid');
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [activeCategory, setActiveCategory] = useState(initialCategory);
  const [categories, setCategories] = useState<{ id: string, title: string }[]>([]);
  const [photos, setPhotos] = useState<CatalogPhoto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  
  // Network status
  const { isOffline } = useNetworkStatus();
  
  // Search hook
  const search = useSearch({
    initialQuery: fromSearch ? initialSearchQuery : '',
    itemsPerPage: 10
  });
  
  // Track if we're in search mode
  const [isSearchMode, setIsSearchMode] = useState(fromSearch);

  // Reset on navigation focus
  useFocusEffect(
    useCallback(() => {
      // Only reset if we're coming in with a new search query
      if (route.params?.searchQuery && fromSearch) {
        setIsSearchMode(true);
        search.setSearchQuery(route.params.searchQuery);
      }
      
      // Reset category if coming from a category selection
      if (route.params?.category && route.params.category !== activeCategory) {
        setActiveCategory(route.params.category);
        setIsSearchMode(false);
        setPage(1);
      }
      
      // Clear route params to prevent issues on re-focus
      if (route.params?.searchQuery || route.params?.category) {
        navigation.setParams({ 
          searchQuery: undefined, 
          category: undefined,
          fromSearch: undefined 
        });
      }
    }, [route.params, navigation, activeCategory, search])
  );

  // Load categories
  useEffect(() => {
    const loadCategories = async () => {
      try {
        const categoryData = await fetchCategories();
        const formattedCategories = [
          { id: 'all', title: 'All Photos' },
          ...categoryData.map(category => ({ id: category, title: category }))
        ];
        setCategories(formattedCategories);
      } catch (err) {
        console.error('Error loading categories:', err);
        setError('Failed to load categories');
      }
    };
    
    loadCategories();
  }, []);

  // Load photos based on active category (not in search mode)
  useEffect(() => {
    if (isSearchMode) return; // Skip when in search mode
    
    const loadPhotos = async () => {
      try {
        setIsLoading(true);
        setError(null);
        
        let photoData: CatalogPhoto[];
        if (activeCategory === 'all') {
          photoData = await fetchCatalogPhotos(1);
        } else {
          photoData = await fetchPhotosByCategory(activeCategory, 1);
        }
        
        setPhotos(photoData);
        setHasMore(photoData.length >= 10);
        setPage(1);
      } catch (err) {
        console.error('Error loading photos:', err);
        setError('Failed to load photos. Pull down to retry.');
      } finally {
        setIsLoading(false);
      }
    };
    
    loadPhotos();
  }, [activeCategory, isSearchMode]);

  // Load more photos (pagination)
  const loadMore = useCallback(async () => {
    // Skip if we're in search mode, loading, or have no more items
    if (isSearchMode || isLoadingMore || !hasMore || hasActiveFilters) return;
    
    try {
      setIsLoadingMore(true);
      
      const nextPage = page + 1;
      let newPhotos: CatalogPhoto[];
      
      if (activeCategory === 'all') {
        newPhotos = await fetchCatalogPhotos(nextPage);
      } else {
        newPhotos = await fetchPhotosByCategory(activeCategory, nextPage);
      }
      
      if (newPhotos.length > 0) {
        setPhotos(prev => [...prev, ...newPhotos]);
        setPage(nextPage);
        setHasMore(newPhotos.length >= 10);
      } else {
        setHasMore(false);
      }
    } catch (err) {
      console.error('Error loading more photos:', err);
      setError('Failed to load more photos');
    } finally {
      setIsLoadingMore(false);
    }
  }, [isSearchMode, isLoadingMore, hasMore, page, activeCategory, hasActiveFilters]);

  // Handle refresh - FIXED to use refreshFilters from closure
  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    
    try {
      if (isSearchMode) {
        // Refresh search results
        search.setSearchQuery(search.query);
      } else if (hasActiveFilters) {
        // Call refreshFilters from the closure (not a new hook call)
        console.log('Refreshing with active filters');
        refreshFilters();
      } else {
        // Regular refresh without filters
        let refreshedPhotos: CatalogPhoto[];
        if (activeCategory === 'all') {
          refreshedPhotos = await fetchCatalogPhotos(1, 10, { useCache: false });
        } else {
          refreshedPhotos = await fetchPhotosByCategory(activeCategory, 1, 10, { useCache: false });
        }
        
        setPhotos(refreshedPhotos);
        setHasMore(refreshedPhotos.length >= 10);
        setPage(1);
        setError(null);
      }
    } catch (err) {
      console.error('Error refreshing photos:', err);
      setError('Failed to refresh photos');
    } finally {
      setIsRefreshing(false);
    }
  }, [isSearchMode, activeCategory, search, hasActiveFilters, refreshFilters]);

  // Handle search
  const handleSearch = useCallback((text: string) => {
    if (!text.trim()) {
      // Clear search
      setIsSearchMode(false);
      return;
    }
    
    // Activate search mode and execute search
    setIsSearchMode(true);
    search.setSearchQuery(text);
  }, [search]);

  // Handle clearing search
  const handleClearSearch = useCallback(() => {
    search.clearSearch();
    setIsSearchMode(false);
  }, [search]);

  // Handle category change
  const handleCategoryChange = useCallback((category: string) => {
    if (category === activeCategory) return;
    
    setActiveCategory(category);
    setIsSearchMode(false); // Exit search mode when changing category
    setPage(1);
    search.clearSearch();
    
    // Also clear any active filters when changing category
    if (hasActiveFilters) {
      clearAllFilters();
    }
  }, [activeCategory, search, hasActiveFilters, clearAllFilters]);

  // Handle photo press
  const handlePhotoPress = useCallback((id: string) => {
    navigation.navigate('PhotoDetail', { id });
  }, [navigation]);

  // Handle end reached (for pagination)
  const handleEndReached = useCallback(() => {
    if (isSearchMode) {
      search.loadMore();
    } else if (!hasActiveFilters) {
      loadMore();
    }
    // We don't load more for filtered results yet
  }, [isSearchMode, search, loadMore, hasActiveFilters]);

  // Handle filter apply
  const handleApplyFilters = useCallback(() => {
    // When filters are applied, we want to exit search mode
    if (isSearchMode) {
      setIsSearchMode(false);
      search.clearSearch();
    }
    
    // Use refreshFilters from closure (not a new hook call)
    refreshFilters();
    handleRefresh();
  }, [isSearchMode, search, refreshFilters, handleRefresh]);

  // Create photo display data
  const getPhotoDisplayData = useCallback(() => {
    // If we have active filters, use filteredResults instead of regular data
    if (hasActiveFilters && !isSearchMode) {
      console.log(`Using ${filteredResults.length} filtered results instead of regular data`);
      return filteredResults.map(photo => ({
        id: photo.image_no,
        title: photo.description || 'Untitled',
        photographer: photo.photographer || 'Unknown',
        price: 49.99, // Default price (in a real app this would come from the API)
        imageUrl: photo.image_url || '',
        location: photo.location || '',
        description: photo.description || ''
      }));
    }
    
    // Otherwise use the original logic
    const sourcePhotos = isSearchMode ? search.results : photos;
    
    return sourcePhotos.map(photo => ({
      id: photo.image_no,
      title: photo.description || 'Untitled',
      photographer: photo.photographer || 'Unknown',
      price: 49.99, // Default price (in a real app this would come from the API)
      imageUrl: photo.image_url || '',
      location: photo.location || '',
      description: photo.description || ''
    }));
  }, [isSearchMode, search.results, photos, hasActiveFilters, filteredResults]);

  // Determine loading state
  const isContentLoading = (isSearchMode 
    ? search.isLoading && !isRefreshing 
    : isLoading && !isRefreshing) || (hasActiveFilters && isFilterLoading && !isRefreshing);

  // Render loading state
  if (isContentLoading) {
    return (
      <SafeAreaView style={styles.container}>
        <GalleryHeader
          onFilterPress={() => setFilterModalVisible(true)}
          viewMode={viewMode}
          setViewMode={setViewMode}
        />
        <SearchBar 
          onSearch={handleSearch}
          onClear={handleClearSearch}
          initialValue={isSearchMode ? search.query : ''}
          executeOnChange={false}
        />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#4f46e5" />
          <Text style={styles.loadingText}>Loading photos...</Text>
        </View>
      </SafeAreaView>
    );
  }

  // Get the photo data to display
  const photoData = getPhotoDisplayData();
  
  // Determine if we should show error state
  const shouldShowError = isSearchMode 
    ? search.isError 
    : hasActiveFilters 
      ? filterError !== null 
      : error !== null;
  
  const errorMessage = isSearchMode 
    ? search.errorMessage 
    : hasActiveFilters 
      ? filterError 
      : error;

  return (
    <SafeAreaView style={styles.container}>
      <GalleryHeader
        onFilterPress={() => setFilterModalVisible(true)}
        viewMode={viewMode}
        setViewMode={setViewMode}
      />
      
      <SearchBar 
        onSearch={handleSearch}
        onClear={handleClearSearch}
        initialValue={isSearchMode ? search.query : ''}
        executeOnChange={false}
      />
      
      {/* Category filter */}
      {!isSearchMode && !hasActiveFilters && (
        <View style={styles.categoryContainer}>
          {categories.length > 0 && (
            <CategoryFilter
              categories={categories}
              activeCategory={activeCategory}
              onCategoryPress={handleCategoryChange}
            />
          )}
        </View>
      )}
      
      {/* Filter active indicator */}
      {hasActiveFilters && !isSearchMode && (
        <View style={styles.filtersActiveContainer}>
          <Text style={styles.filtersActiveText}>
            Filters applied
          </Text>
          <TouchableOpacity 
            onPress={clearAllFilters}
            style={styles.clearFiltersButton}
          >
            <Text style={styles.clearFiltersText}>Clear Filters</Text>
          </TouchableOpacity>
        </View>
      )}
      
      {/* Search active indicator */}
      {isSearchMode && search.query && (
        <View style={styles.searchActiveContainer}>
          <View style={styles.searchInfoContainer}>
            <Text style={styles.searchActiveText}>
              Showing results for "{search.query}"
            </Text>
            <Text style={styles.resultCountText}>
              {search.results.length} {search.results.length === 1 ? 'result' : 'results'}
              {search.hasMore ? '+' : ''}
            </Text>
          </View>
          <TouchableOpacity 
            onPress={handleClearSearch}
            style={styles.clearSearchButton}
          >
            <Text style={styles.clearSearchText}>Clear</Text>
          </TouchableOpacity>
        </View>
      )}
      
      {/* Result count for regular browsing */}
      {!isSearchMode && !hasActiveFilters && photos.length > 0 && (
        <View style={styles.resultCountContainer}>
          <Text style={styles.resultCountText}>
            {photos.length} {photos.length === 1 ? 'photo' : 'photos'}
            {hasMore ? '+' : ''}
            {activeCategory !== 'all' && ` in "${categories.find(c => c.id === activeCategory)?.title || activeCategory}"`}
          </Text>
        </View>
      )}
      
      {/* Network offline indicator */}
      {isOffline && (
        <View style={styles.offlineContainer}>
          <Text style={styles.offlineText}>
            You are offline. Some features may be limited.
          </Text>
        </View>
      )}
      
      {/* Photo list */}
      <PhotoList
        photos={photoData}
        viewMode={viewMode}
        onPhotoPress={handlePhotoPress}
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={handleRefresh}
            colors={['#4f46e5']}
            tintColor="#4f46e5"
          />
        }
        onEndReached={handleEndReached}
        onEndReachedThreshold={0.5}
        ListHeaderComponent={
          shouldShowError ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{errorMessage}</Text>
            </View>
          ) : null
        }
        ListFooterComponent={
          (isSearchMode 
            ? search.isLoading && !search.isError 
            : !hasActiveFilters && isLoadingMore) ? (
            <View style={styles.loadingMore}>
              <ActivityIndicator size="small" color="#4f46e5" />
            </View>
          ) : null
        }
        ListEmptyComponent={
          !isContentLoading && photoData.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>
                {isSearchMode 
                  ? `No results found for "${search.query}"` 
                  : hasActiveFilters
                    ? 'No photos match the applied filters'
                    : 'No photos available'
                }
              </Text>
            </View>
          ) : null
        }
      />
      
      {/* Debug component (only in development mode) */}
      {__DEV__ && <FilterDebugger />}
      
      {/* Advanced Filter Modal */}
      <AdvancedFilterModal
        visible={filterModalVisible}
        onClose={() => setFilterModalVisible(false)}
        onApplyFilters={handleApplyFilters}
        resultCount={photoData.length}
        hasMoreResults={isSearchMode ? search.hasMore : hasMore}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  categoryContainer: {
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  errorContainer: {
    padding: 20,
    alignItems: 'center',
  },
  errorText: {
    fontSize: 16,
    color: '#ef4444',
    textAlign: 'center',
  },
  loadingMore: {
    padding: 20,
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#6b7280',
    textAlign: 'center',
    marginTop: 16,
  },
  searchActiveContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#f0f9ff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0f2fe',
  },
  filtersActiveContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#f0f8ff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0f2fe',
  },
  searchInfoContainer: {
    flex: 1,
  },
  searchActiveText: {
    fontSize: 14,
    color: '#0369a1',
  },
  filtersActiveText: {
    fontSize: 14,
    color: '#0369a1',
  },
  clearSearchButton: {
    paddingVertical: 4,
    paddingHorizontal: 8,
  },
  clearFiltersButton: {
    paddingVertical: 4,
    paddingHorizontal: 8, 
  },
  clearSearchText: {
    fontSize: 14,
    color: '#0ea5e9',
    fontWeight: '500',
  },
  clearFiltersText: {
    fontSize: 14,
    color: '#0ea5e9',
    fontWeight: '500',
  },
  offlineContainer: {
    padding: 8,
    backgroundColor: '#fee2e2',
    alignItems: 'center',
  },
  offlineText: {
    fontSize: 14,
    color: '#dc2626',
  },
  resultCountText: {
    fontSize: 12,
    color: '#6b7280',
    marginTop: 2,
  },
  resultCountContainer: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#f9fafb',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
});

// Wrap the main GalleryScreen component with FilterProvider
const GalleryScreenWithFilters = ({ navigation, route }) => (
  <FilterProvider>
    <GalleryScreen navigation={navigation} route={route} />
  </FilterProvider>
);

export default GalleryScreenWithFilters;
===== ./src/screens/HomeScreen.tsx =====
// HomeScreen.tsx
import React, { useState, useEffect } from 'react';
import { ScrollView, StyleSheet, View } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';

// Import components
import HeaderSection from '../components/HeaderSection';
import WelcomeSection from '../components/WelcomeSection';
import CategoriesSection from '../components/CategoriesSection';
import FeaturedPhotoSection from '../components/FeaturedPhotoSection';
import SearchBar from '../components/SearchBar';
import { fetchCategories } from '../services/catalogService';

const HomeScreen = ({ navigation }) => {
  const [categories, setCategories] = useState([
    { id: 'steam', title: 'Steam Locomotives', icon: 'train' },
    { id: 'modern', title: 'Modern Trains', icon: 'subway' },
    { id: 'stations', title: 'Railway Stations', icon: 'business' },
    { id: 'scenic', title: 'Scenic Railways', icon: 'image' },
  ]);
  const [isLoading, setIsLoading] = useState(false);

  // Sample featured photo (this could come from an API in a real app)
  const featuredPhoto = {
    id: 'featured1',
    title: 'Vintage Steam Engine',
    description: 'A beautifully restored steam locomotive passing through mountain scenery.',
    photographer: 'John Smith',
    location: 'Swiss Alps',
    price: 49.99,
    imageUrl: 'https://images.unsplash.com/photo-1527684651001-731c474bbb5a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80',
  };

  // Load categories from the API
  useEffect(() => {
    const loadCategories = async () => {
      try {
        setIsLoading(true);
        const categoryData = await fetchCategories();
        
        // Map categories to the format our component expects
        const categoryIcons = {
          'steam': 'train',
          'modern': 'subway',
          'stations': 'business',
          'scenic': 'image',
          'historical': 'time',
          'passenger': 'people',
          'freight': 'cube',
          'railway': 'git-branch'
        };
        
        // Create formatted categories with icons
        const formattedCategories = categoryData.map(category => {
          // Use a matching icon if available, or a default icon
          const icon = categoryIcons[category.toLowerCase()] || 'image';
          return { id: category, title: category, icon };
        });
        
        // Limit to the first 8 categories for display
        setCategories(formattedCategories.slice(0, 8));
      } catch (error) {
        console.error('Failed to load categories:', error);
        // Keep default categories on error
      } finally {
        setIsLoading(false);
      }
    };
    
    loadCategories();
  }, []);

  // Handle search
  const handleSearch = (searchText: string) => {
    if (!searchText.trim()) return;
    
    // Navigate to Gallery with search query
    navigation.navigate('Gallery', { 
      searchQuery: searchText,
      fromSearch: true // Flag to indicate this is from search
    });
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView showsVerticalScrollIndicator={false}>
        <HeaderSection 
          onCartPress={() => navigation.navigate('Cart')} 
        />
        
        {/* Search Bar */}
        <View style={styles.searchContainer}>
          <SearchBar 
            onSearch={handleSearch}
            placeholder="Search train photographs..."
            executeOnChange={false} // Only search when submitted
          />
        </View>
        
        <WelcomeSection 
          onBrowsePress={() => navigation.navigate('Gallery')} 
        />
        
        <CategoriesSection 
          categories={categories}
          onCategoryPress={(categoryId) => navigation.navigate('Gallery', { category: categoryId })}
        />
        
        <FeaturedPhotoSection
          featuredPhoto={featuredPhoto}
          onViewDetailsPress={(photoId) => navigation.navigate('PhotoDetail', { id: photoId })}
        />
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  searchContainer: {
    paddingHorizontal: 16,
    marginBottom: 8,
  },
});

export default HomeScreen;
===== ./src/screens/PhotoDetailScreen.tsx =====

import React, { useState, useEffect } from 'react';
import { 
  View, Text, StyleSheet, Image, ScrollView, 
  TouchableOpacity, ActivityIndicator, Alert 
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { fetchPhotoById, getImageUrl } from '../services/catalogService';

const PhotoDetailScreen = ({ route, navigation }) => {
  const { id } = route.params;
  const [photo, setPhoto] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isInCart, setIsInCart] = useState(false);
  const [isFavorite, setIsFavorite] = useState(false);
  
  useEffect(() => {
    const loadPhoto = async () => {
      try {
        setIsLoading(true);
        setError(null);
        
        const photoData = await fetchPhotoById(id);
        if (!photoData) {
          throw new Error('Photo not found');
        }
        
        setPhoto(photoData);
      } catch (err) {
        console.error('Error loading photo details:', err);
        setError('Failed to load photo details. Please try again later.');
      } finally {
        setIsLoading(false);
      }
    };
    
    loadPhoto();
  }, [id]);
  
  const handleAddToCart = () => {
    // In a real implementation, this would add the photo to the cart in a state manager
    setIsInCart(true);
    Alert.alert('Added to Cart', 'This photo has been added to your cart.');
  };
  
  const handleToggleFavorite = () => {
    setIsFavorite(!isFavorite);
    Alert.alert(
      isFavorite ? 'Removed from Favorites' : 'Added to Favorites', 
      isFavorite ? 'This photo has been removed from your favorites.' : 'This photo has been added to your favorites.'
    );
  };

  if (isLoading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4f46e5" />
        <Text style={styles.loadingText}>Loading photo details...</Text>
      </SafeAreaView>
    );
  }
  
  if (error || !photo) {
    return (
      <SafeAreaView style={styles.errorContainer}>
        <Text style={styles.errorText}>{error || 'Photo not found'}</Text>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.backButtonText}>Go Back</Text>
        </TouchableOpacity>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      {/* Header with back button */}
      <View style={styles.header}>
        <TouchableOpacity 
          onPress={() => navigation.goBack()} 
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={24} color="#374151" />
        </TouchableOpacity>
        <View style={{ flex: 1 }} />
        <TouchableOpacity 
          onPress={handleToggleFavorite} 
          style={styles.favoriteButton}
        >
          <Ionicons 
            name={isFavorite ? 'heart' : 'heart-outline'} 
            size={24} 
            color={isFavorite ? '#ef4444' : '#374151'} 
          />
        </TouchableOpacity>
      </View>
      
      <ScrollView contentContainerStyle={styles.content}>
        {/* Photo Image */}
        <Image 
          source={{ uri: getImageUrl(photo.image_no) }}
          style={styles.photoImage}
          resizeMode="contain"
        />
        
        {/* Photo Details */}
        <View style={styles.detailsContainer}>
          <Text style={styles.photoTitle}>{photo.description || 'Untitled'}</Text>
          
          <View style={styles.photographerContainer}>
            <Text style={styles.photographerLabel}>Photographer:</Text>
            <Text style={styles.photographerName}>{photo.photographer || 'Unknown'}</Text>
          </View>
          
          <View style={styles.detailRow}>
            <View style={styles.detailItem}>
              <Text style={styles.detailLabel}>Location</Text>
              <Text style={styles.detailValue}>{photo.location || 'Unknown'}</Text>
            </View>
            <View style={styles.detailItem}>
              <Text style={styles.detailLabel}>Category</Text>
              <Text style={styles.detailValue}>{photo.category || 'Uncategorized'}</Text>
            </View>
          </View>
          
          <View style={styles.detailRow}>
            <View style={styles.detailItem}>
              <Text style={styles.detailLabel}>Date Taken</Text>
              <Text style={styles.detailValue}>
                {photo.date_taken 
                  ? new Date(photo.date_taken).toLocaleDateString() 
                  : 'Unknown'}
                {photo.circa ? ' (circa)' : ''}
              </Text>
            </View>
            <View style={styles.detailItem}>
              <Text style={styles.detailLabel}>Collection</Text>
              <Text style={styles.detailValue}>{photo.collection || 'General'}</Text>
            </View>
          </View>
          
          {photo.description && (
            <View style={styles.descriptionContainer}>
              <Text style={styles.descriptionLabel}>Description</Text>
              <Text style={styles.descriptionText}>{photo.description}</Text>
            </View>
          )}
          
          {/* Image Metadata */}
          <View style={styles.metadataContainer}>
            <Text style={styles.metadataTitle}>Image Details</Text>
            
            <View style={styles.metadataGrid}>
              {photo.width && photo.height && (
                <View style={styles.metadataItem}>
                  <Text style={styles.metadataLabel}>Dimensions</Text>
                  <Text style={styles.metadataValue}>{photo.width} x {photo.height}px</Text>
                </View>
              )}
              
              {photo.file_type && (
                <View style={styles.metadataItem}>
                  <Text style={styles.metadataLabel}>File Type</Text>
                  <Text style={styles.metadataValue}>{photo.file_type}</Text>
                </View>
              )}
              
              {photo.resolution && (
                <View style={styles.metadataItem}>
                  <Text style={styles.metadataLabel}>Resolution</Text>
                  <Text style={styles.metadataValue}>{photo.resolution} DPI</Text>
                </View>
              )}
              
              {photo.colour_space && (
                <View style={styles.metadataItem}>
                  <Text style={styles.metadataLabel}>Color Space</Text>
                  <Text style={styles.metadataValue}>{photo.colour_space}</Text>
                </View>
              )}
            </View>
          </View>
          
          {/* Train Details */}
          {photo.gauge && (
            <View style={styles.trainDetailsContainer}>
              <Text style={styles.trainDetailsTitle}>Train Details</Text>
              
              <View style={styles.trainDetailItem}>
                <Text style={styles.trainDetailLabel}>Gauge:</Text>
                <Text style={styles.trainDetailValue}>{photo.gauge}</Text>
              </View>
              
              {photo.builders && photo.builders.length > 0 && (
                <View style={styles.trainDetailItem}>
                  <Text style={styles.trainDetailLabel}>Builder:</Text>
                  <Text style={styles.trainDetailValue}>
                    {photo.builders[0].builder_name}
                    {photo.builders[0].works_number ? ` (${photo.builders[0].works_number})` : ''}
                  </Text>
                </View>
              )}
              
              {photo.builders && photo.builders.length > 0 && photo.builders[0].year_built && (
                <View style={styles.trainDetailItem}>
                  <Text style={styles.trainDetailLabel}>Year Built:</Text>
                  <Text style={styles.trainDetailValue}>{photo.builders[0].year_built}</Text>
                </View>
              )}
            </View>
          )}
          
          {/* Usage Rights */}
          <View style={styles.usageContainer}>
            <Text style={styles.usageTitle}>Usage Rights</Text>
            
            <View style={styles.usageItem}>
              <Text style={styles.usageLabel}>Prints Allowed:</Text>
              <View style={[
                styles.usageBadge, 
                photo.prints_allowed ? styles.allowedBadge : styles.notAllowedBadge
              ]}>
                <Text style={styles.usageBadgeText}>
                  {photo.prints_allowed ? 'Yes' : 'No'}
                </Text>
              </View>
            </View>
            
            <View style={styles.usageItem}>
              <Text style={styles.usageLabel}>Internet Use:</Text>
              <View style={[
                styles.usageBadge, 
                photo.internet_use ? styles.allowedBadge : styles.notAllowedBadge
              ]}>
                <Text style={styles.usageBadgeText}>
                  {photo.internet_use ? 'Yes' : 'No'}
                </Text>
              </View>
            </View>
            
            <View style={styles.usageItem}>
              <Text style={styles.usageLabel}>Publications Use:</Text>
              <View style={[
                styles.usageBadge, 
                photo.publications_use ? styles.allowedBadge : styles.notAllowedBadge
              ]}>
                <Text style={styles.usageBadgeText}>
                  {photo.publications_use ? 'Yes' : 'No'}
                </Text>
              </View>
            </View>
          </View>
        </View>
      </ScrollView>
      
      {/* Purchase button */}
      <View style={styles.footer}>
        <View style={styles.priceContainer}>
          <Text style={styles.priceLabel}>Price</Text>
          <Text style={styles.price}>$49.99</Text>
        </View>
        
        <TouchableOpacity 
          style={[styles.purchaseButton, isInCart && styles.inCartButton]}
          onPress={handleAddToCart}
          disabled={isInCart}
        >
          <Text style={styles.purchaseButtonText}>
            {isInCart ? 'Added to Cart' : 'Add to Cart'}
          </Text>
          <Ionicons 
            name={isInCart ? 'checkmark-circle' : 'cart-outline'} 
            size={20} 
            color="#ffffff" 
            style={styles.purchaseButtonIcon} 
          />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#ef4444',
    textAlign: 'center',
    marginBottom: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
    backgroundColor: '#ffffff',
  },
  backButton: {
    padding: 8,
  },
  favoriteButton: {
    padding: 8,
  },
  shareButton: {
    padding: 8,
    marginRight: 8,
  },
  content: {
    paddingBottom: 90,
  },
  photoImage: {
    width: '100%',
    height: 300,
    backgroundColor: '#f3f4f6',
  },
  detailsContainer: {
    padding: 16,
    backgroundColor: '#ffffff',
  },
  photoTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 12,
  },
  photographerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  photographerLabel: {
    fontSize: 14,
    color: '#6b7280',
    marginRight: 4,
  },
  photographerName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#4b5563',
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  detailItem: {
    flex: 1,
  },
  detailLabel: {
    fontSize: 12,
    color: '#6b7280',
    marginBottom: 2,
  },
  detailValue: {
    fontSize: 14,
    color: '#1f2937',
  },
  descriptionContainer: {
    marginTop: 8,
    marginBottom: 16,
  },
  descriptionLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#4b5563',
    marginBottom: 6,
  },
  descriptionText: {
    fontSize: 14,
    color: '#4b5563',
    lineHeight: 20,
  },
  metadataContainer: {
    marginTop: 8,
    padding: 12,
    backgroundColor: '#f9fafb',
    borderRadius: 8,
    marginBottom: 16,
  },
  metadataTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 12,
  },
  metadataGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  metadataItem: {
    width: '50%',
    marginBottom: 8,
  },
  metadataLabel: {
    fontSize: 12,
    color: '#6b7280',
  },
  metadataValue: {
    fontSize: 14,
    color: '#1f2937',
  },
  trainDetailsContainer: {
    marginBottom: 16,
    padding: 12,
    backgroundColor: '#f9fafb',
    borderRadius: 8,
  },
  trainDetailsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 12,
  },
  trainDetailItem: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  trainDetailLabel: {
    fontSize: 14,
    color: '#6b7280',
    width: 90,
  },
  trainDetailValue: {
    fontSize: 14,
    color: '#1f2937',
    flex: 1,
  },
  usageContainer: {
    marginBottom: 16,
    padding: 12,
    backgroundColor: '#f9fafb',
    borderRadius: 8,
  },
  usageTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#4b5563',
    marginBottom: 12,
  },
  usageItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  usageLabel: {
    fontSize: 14,
    color: '#4b5563',
  },
  usageBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  allowedBadge: {
    backgroundColor: '#d1fae5',
  },
  notAllowedBadge: {
    backgroundColor: '#fee2e2',
  },
  usageBadgeText: {
    fontSize: 12,
    fontWeight: '500',
  },
  footer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: '#e5e7eb',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 5,
  },
  priceContainer: {
    flex: 1,
  },
  priceLabel: {
    fontSize: 12,
    color: '#6b7280',
  },
  price: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  purchaseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4f46e5',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  inCartButton: {
    backgroundColor: '#10b981',
  },
  purchaseButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  purchaseButtonIcon: {
    marginLeft: 8,
  },
});

export default PhotoDetailScreen;

===== ./src/screens/ProfileScreen.tsx =====
// ProfileScreen.tsx  
import React, { useState } from 'react';
import { 
  View, Text, StyleSheet, ScrollView, 
  TouchableOpacity, Image, Alert, ActivityIndicator,
  TextInput, Modal
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '@/context/AuthContext';

const ProfileScreen = ({ navigation }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState('profile'); // profile, orders, favorites
  const [editProfileVisible, setEditProfileVisible] = useState(false);
  const [changePasswordVisible, setChangePasswordVisible] = useState(false);
  
  const [name, setName] = useState('');
  const [avatarUrl, setAvatarUrl] = useState('');
  
  const [currentPassword, setCurrentPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  
  const { logout, userProfile, isAdmin, updateProfile, changePassword, refreshProfile } = useAuth();

  const handleLogout = async () => {
    Alert.alert(
      "Logout",
      "Are you sure you want to log out?",
      [
        { text: "Cancel", style: "cancel" },
        { 
          text: "Logout", 
          onPress: async () => {
            try {
              setIsLoading(true);
              await logout();
              // After logout, the auth state change will navigate back to login
              setIsLoading(false);
            } catch (error) {
              console.error('Error during logout:', error);
              Alert.alert("Error", "Failed to log out. Please try again.");
              setIsLoading(false);
            }
          }
        }
      ]
    );
  };

  const handleEditProfile = () => {
    if (userProfile) {
      setName(userProfile.name || '');
      setAvatarUrl(userProfile.avatar_url || '');
      setEditProfileVisible(true);
    }
  };

  const handleSaveProfile = async () => {
    try {
      setIsLoading(true);
      await updateProfile({
        name,
        avatar_url: avatarUrl
      });
      setEditProfileVisible(false);
      await refreshProfile();
    } catch (error) {
      console.error('Error saving profile:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleChangePassword = () => {
    setCurrentPassword('');
    setNewPassword('');
    setConfirmPassword('');
    setChangePasswordVisible(true);
  };

  const handleSavePassword = async () => {
    if (newPassword !== confirmPassword) {
      Alert.alert("Error", "New passwords do not match");
      return;
    }

    if (newPassword.length < 6) {
      Alert.alert("Error", "New password must be at least 6 characters");
      return;
    }

    try {
      setIsLoading(true);
      await changePassword(currentPassword, newPassword);
      setChangePasswordVisible(false);
    } catch (error) {
      console.error('Error changing password:', error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4f46e5" />
        <Text style={styles.loadingText}>Loading profile...</Text>
      </SafeAreaView>
    );
  }

  // Use the user data from context
  const userData = userProfile || {
    name: "User",
    email: "user@example.com",
    avatar_url: "https://randomuser.me/api/portraits/men/32.jpg",
    memberSince: "Recently",
    orders: [],
    favorites: []
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Profile Header */}
      <View style={styles.header}>
        <View style={styles.profileInfo}>
          <Image 
            source={{ uri: userData.avatar_url || "https://randomuser.me/api/portraits/men/32.jpg" }}
            style={styles.avatar}
          />
          <View style={styles.userInfo}>
            <Text style={styles.userName}>{userData.name || "User"}</Text>
            <Text style={styles.memberSince}>Member since {new Date(userData.created_at || Date.now()).toLocaleDateString('en-US', { year: 'numeric', month: 'long' })}</Text>
            {isAdmin && (
              <View style={styles.adminBadge}>
                <Text style={styles.adminBadgeText}>Admin</Text>
              </View>
            )}
          </View>
        </View>
      </View>

      {/* Tab Navigation */}
      <View style={styles.tabContainer}>
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'profile' && styles.activeTab]}
          onPress={() => setActiveTab('profile')}
        >
          <Text style={[styles.tabText, activeTab === 'profile' && styles.activeTabText]}>Profile</Text>
        </TouchableOpacity>
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'orders' && styles.activeTab]}
          onPress={() => setActiveTab('orders')}
        >
          <Text style={[styles.tabText, activeTab === 'orders' && styles.activeTabText]}>Orders</Text>
        </TouchableOpacity>
        <TouchableOpacity 
          style={[styles.tab, activeTab === 'favorites' && styles.activeTab]}
          onPress={() => setActiveTab('favorites')}
        >
          <Text style={[styles.tabText, activeTab === 'favorites' && styles.activeTabText]}>Favorites</Text>
        </TouchableOpacity>
      </View>

      <ScrollView contentContainerStyle={styles.scrollContent}>
        {activeTab === 'profile' && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Account Settings</Text>
            
            <TouchableOpacity style={styles.settingItem} onPress={handleEditProfile}>
              <View style={styles.settingIconContainer}>
                <Ionicons name="person-outline" size={20} color="#4f46e5" />
              </View>
              <Text style={styles.settingText}>Edit Profile</Text>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={styles.settingItem}
              onPress={handleChangePassword}
            >
              <View style={styles.settingIconContainer}>
                <Ionicons name="lock-closed-outline" size={20} color="#4f46e5" />
              </View>
              <Text style={styles.settingText}>Change Password</Text>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.settingItem}>
              <View style={styles.settingIconContainer}>
                <Ionicons name="notifications-outline" size={20} color="#4f46e5" />
              </View>
              <Text style={styles.settingText}>Notification Settings</Text>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.settingItem}>
              <View style={styles.settingIconContainer}>
                <Ionicons name="card-outline" size={20} color="#4f46e5" />
              </View>
              <Text style={styles.settingText}>Payment Methods</Text>
              <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
            </TouchableOpacity>
            
            {isAdmin && (
              <TouchableOpacity 
                style={styles.settingItem}
                onPress={() => navigation.navigate('Admin')}
              >
                <View style={styles.settingIconContainer}>
                  <Ionicons name="settings-outline" size={20} color="#4f46e5" />
                </View>
                <Text style={styles.settingText}>Admin Dashboard</Text>
                <Ionicons name="chevron-forward" size={20} color="#9ca3af" />
              </TouchableOpacity>
            )}
            
            <TouchableOpacity 
              style={[styles.settingItem, styles.logoutItem]}
              onPress={handleLogout}
            >
              <View style={[styles.settingIconContainer, styles.logoutIconContainer]}>
                <Ionicons name="log-out-outline" size={20} color="#ef4444" />
              </View>
              <Text style={styles.logoutText}>Logout</Text>
            </TouchableOpacity>
          </View>
        )}

        {activeTab === 'orders' && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Orders</Text>
            
            {userData.orders.length > 0 ? (
              userData.orders.map((order) => (
                <TouchableOpacity 
                  key={order.id}
                  style={styles.orderItem}
                >
                  <View style={styles.orderHeader}>
                    <Text style={styles.orderId}>{order.id}</Text>
                    <View style={[
                      styles.orderStatusBadge,
                      order.status === "Completed" ? styles.completedStatus : styles.processingStatus
                    ]}>
                      <Text style={styles.orderStatusText}>{order.status}</Text>
                    </View>
                  </View>
                  
                  <View style={styles.orderDetails}>
                    <Text style={styles.orderDate}>Ordered on {order.date}</Text>
                    <Text style={styles.orderTotal}>${order.total.toFixed(2)}</Text>
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <View style={styles.emptyStateContainer}>
                <Ionicons name="receipt-outline" size={48} color="#d1d5db" />
                <Text style={styles.emptyStateTitle}>No orders yet</Text>
                <Text style={styles.emptyStateMessage}>
                  Your order history will appear here
                </Text>
                <TouchableOpacity
                  style={styles.browseButton}
                  onPress={() => navigation.navigate('Gallery')}
                >
                  <Text style={styles.browseButtonText}>Start Shopping</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        )}

        {activeTab === 'favorites' && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Favorites</Text>
            
            {userData.favorites.length > 0 ? (
              userData.favorites.map((favorite) => (
                <TouchableOpacity 
                  key={favorite.id}
                  style={styles.favoriteItem}
                  onPress={() => navigation.navigate('PhotoDetail', { id: favorite.id })}
                >
                  <Image 
                    source={{ uri: favorite.imageUrl }}
                    style={styles.favoriteImage}
                  />
                  <View style={styles.favoriteDetails}>
                    <Text style={styles.favoriteTitle}>{favorite.title}</Text>
                    <Text style={styles.favoritePhotographer}>{favorite.photographer}</Text>
                  </View>
                  <TouchableOpacity style={styles.favoriteRemoveButton}>
                    <Ionicons name="heart" size={20} color="#ef4444" />
                  </TouchableOpacity>
                </TouchableOpacity>
              ))
            ) : (
              <View style={styles.emptyStateContainer}>
                <Ionicons name="heart-outline" size={48} color="#d1d5db" />
                <Text style={styles.emptyStateTitle}>No favorites yet</Text>
                <Text style={styles.emptyStateMessage}>
                  Save photos you like for later
                </Text>
                <TouchableOpacity
                  style={styles.browseButton}
                  onPress={() => navigation.navigate('Gallery')}
                >
                  <Text style={styles.browseButtonText}>Browse Photos</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        )}
      </ScrollView>

      {/* Edit Profile Modal */}
      <Modal
        visible={editProfileVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setEditProfileVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Edit Profile</Text>
              <TouchableOpacity onPress={() => setEditProfileVisible(false)}>
                <Ionicons name="close" size={24} color="#4b5563" />
              </TouchableOpacity>
            </View>
            
            <View style={styles.modalContent}>
              <View style={styles.formGroup}>
                <Text style={styles.label}>Display Name</Text>
                <TextInput
                  style={styles.input}
                  value={name}
                  onChangeText={setName}
                  placeholder="Your display name"
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.label}>Avatar URL</Text>
                <TextInput
                  style={styles.input}
                  value={avatarUrl}
                  onChangeText={setAvatarUrl}
                  placeholder="URL to your avatar image"
                />
              </View>
              
              {avatarUrl ? (
                <View style={styles.avatarPreview}>
                  <Text style={styles.previewLabel}>Preview:</Text>
                  <Image
                    source={{ uri: avatarUrl }}
                    style={styles.previewAvatar}
                    onError={() => Alert.alert("Error", "Could not load image from URL")}
                  />
                </View>
              ) : null}
              
              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleSaveProfile}
                disabled={isLoading}
              >
                {isLoading ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <Text style={styles.saveButtonText}>Save Changes</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Change Password Modal */}
      <Modal
        visible={changePasswordVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setChangePasswordVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Change Password</Text>
              <TouchableOpacity onPress={() => setChangePasswordVisible(false)}>
                <Ionicons name="close" size={24} color="#4b5563" />
              </TouchableOpacity>
            </View>
            
            <View style={styles.modalContent}>
              <View style={styles.formGroup}>
                <Text style={styles.label}>Current Password</Text>
                <TextInput
                  style={styles.input}
                  value={currentPassword}
                  onChangeText={setCurrentPassword}
                  placeholder="Your current password"
                  secureTextEntry
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.label}>New Password</Text>
                <TextInput
                  style={styles.input}
                  value={newPassword}
                  onChangeText={setNewPassword}
                  placeholder="Your new password"
                  secureTextEntry
                />
              </View>
              
              <View style={styles.formGroup}>
                <Text style={styles.label}>Confirm New Password</Text>
                <TextInput
                  style={styles.input}
                  value={confirmPassword}
                  onChangeText={setConfirmPassword}
                  placeholder="Confirm your new password"
                  secureTextEntry
                />
              </View>
              
              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleSavePassword}
                disabled={isLoading}
              >
                {isLoading ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <Text style={styles.saveButtonText}>Change Password</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6b7280',
  },
  header: {
    backgroundColor: '#ffffff',
    paddingVertical: 20,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  profileInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    borderWidth: 3,
    borderColor: '#e5e7eb',
  },
  userInfo: {
    marginLeft: 16,
  },
  userName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  userEmail: {
    fontSize: 14,
    color: '#4b5563',
    marginBottom: 4,
  },
  memberSince: {
    fontSize: 12,
    color: '#6b7280',
  },
  tabContainer: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#4f46e5',
  },
  tabText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#6b7280',
  },
  activeTabText: {
    color: '#4f46e5',
  },
  scrollContent: {
    paddingBottom: 20,
  },
  sectionContainer: {
    backgroundColor: '#ffffff',
    marginTop: 16,
    borderRadius: 8,
    padding: 16,
    margin: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1f2937',
    marginBottom: 16,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
  },
  settingIconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#f3f4f6',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  settingText: {
    flex: 1,
    fontSize: 16,
    color: '#1f2937',
  },
  logoutItem: {
    borderBottomWidth: 0,
    marginTop: 16,
  },
  logoutIconContainer: {
    backgroundColor: '#fee2e2',
  },
  logoutText: {
    flex: 1,
    fontSize: 16,
    color: '#ef4444',
  },
  orderItem: {
    backgroundColor: '#f9fafb',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
  },
  orderHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  orderId: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1f2937',
  },
  orderStatusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 16,
  },
  completedStatus: {
    backgroundColor: '#dcfce7',
  },
  processingStatus: {
    backgroundColor: '#ffedd5',
  },
  orderStatusText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#166534',
  },
  orderDetails: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  orderDate: {
    fontSize: 14,
    color: '#6b7280',
  },
  orderTotal: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1f2937',
  },
  favoriteItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f3f4f6',
  },
  favoriteImage: {
    width: 60,
    height: 60,
    borderRadius: 4,
  },
  favoriteDetails: {
    flex: 1,
    marginLeft: 12,
  },
  favoriteTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#1f2937',
  },
  favoritePhotographer: {
    fontSize: 14,
    color: '#6b7280',
  },
  favoriteRemoveButton: {
    padding: 8,
  },
  emptyStateContainer: {
    alignItems: 'center',
    padding: 20,
  },
  emptyStateTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyStateMessage: {
    fontSize: 14,
    color: '#6b7280',
    textAlign: 'center',
    marginBottom: 20,
  },
  browseButton: {
    backgroundColor: '#4f46e5',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  browseButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  
  adminBadge: {
    backgroundColor: '#4f46e5',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
    marginTop: 4,
    alignSelf: 'flex-start',
  },
  adminBadgeText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
  },
  
  // Modal styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    width: '100%',
    maxWidth: 500,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1f2937',
  },
  modalContent: {
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#4b5563',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f9fafb',
    borderWidth: 1,
    borderColor: '#d1d5db',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  avatarPreview: {
    alignItems: 'center',
    marginVertical: 16,
  },
  previewLabel: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 8,
  },
  previewAvatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
  },
  saveButton: {
    backgroundColor: '#4f46e5',
    borderRadius: 8,
    padding: 12,
    alignItems: 'center',
    marginTop: 16,
  },
  saveButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default ProfileScreen;

===== ./src/services/authService.js =====

import AsyncStorage from '@react-native-async-storage/async-storage';

// Mock user data for demo purposes
const USERS = [
  {
    id: '1',
    name: 'Admin User',
    email: 'admin@example.com',
    password: 'admin123',
    role: 'admin'
  },
  {
    id: '2',
    name: 'Regular User',
    email: 'user@example.com',
    password: 'user123',
    role: 'user'
  }
];

export const login = async (email, password) => {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const user = USERS.find(
    user => user.email.toLowerCase() === email.toLowerCase() && user.password === password
  );
  
  if (!user) {
    throw new Error('Invalid email or password');
  }
  
  // Create a user session object without the password
  const userSession = {
    id: user.id,
    name: user.name,
    email: user.email,
    role: user.role,
    token: `mock-jwt-token-${user.id}`,
  };
  
  // Save the session data to AsyncStorage
  await AsyncStorage.setItem('userToken', userSession.token);
  await AsyncStorage.setItem('userRole', userSession.role);
  await AsyncStorage.setItem('userProfile', JSON.stringify(userSession));
  
  return userSession;
};

export const register = async (name, email, password) => {
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Check if user already exists
  const existingUser = USERS.find(
    user => user.email.toLowerCase() === email.toLowerCase()
  );
  
  if (existingUser) {
    throw new Error('User with this email already exists');
  }
  
  // In a real app, this would be a POST request to your API
  // For this demo, we'll just create a mock user
  const newUser = {
    id: `${USERS.length + 1}`,
    name,
    email,
    password,
    role: 'user'
  };
  
  // Add user to our mock database
  USERS.push(newUser);
  
  // Create user session without the password
  const userSession = {
    id: newUser.id,
    name: newUser.name,
    email: newUser.email,
    role: newUser.role,
    token: `mock-jwt-token-${newUser.id}`,
  };
  
  // Save the session data
  await AsyncStorage.setItem('userToken', userSession.token);
  await AsyncStorage.setItem('userRole', userSession.role);
  await AsyncStorage.setItem('userProfile', JSON.stringify(userSession));
  
  return userSession;
};

export const logout = async () => {
  // Remove all session data
  await AsyncStorage.removeItem('userToken');
  await AsyncStorage.removeItem('userRole');
  await AsyncStorage.removeItem('userProfile');
};

export const getCurrentUser = async () => {
  const userProfileJson = await AsyncStorage.getItem('userProfile');
  if (!userProfileJson) {
    return null;
  }
  return JSON.parse(userProfileJson);
};

export const checkAuth = async () => {
  const token = await AsyncStorage.getItem('userToken');
  const role = await AsyncStorage.getItem('userRole');
  
  if (!token) {
    return { isAuthenticated: false, isAdmin: false };
  }
  
  return { 
    isAuthenticated: true, 
    isAdmin: role === 'admin' 
  };
};

===== ./src/services/cartService.js =====

import AsyncStorage from '@react-native-async-storage/async-storage';
import { getPhotoById } from './photoService';

const CART_STORAGE_KEY = 'user_cart';

// Get cart items with full photo details
export const getCartItems = async () => {
  try {
    // Get cart from storage
    const cartData = await AsyncStorage.getItem(CART_STORAGE_KEY);
    const cart = cartData ? JSON.parse(cartData) : [];
    
    // If cart is empty, return empty array
    if (cart.length === 0) {
      return [];
    }
    
    // Get full details for each photo in cart
    const cartItemsWithDetails = await Promise.all(
      cart.map(async (item) => {
        const photo = await getPhotoById(item.id);
        return {
          ...photo,
          quantity: item.quantity
        };
      })
    );
    
    return cartItemsWithDetails;
  } catch (error) {
    console.error('Error fetching cart items:', error);
    return [];
  }
};

// Add item to cart
export const addToCart = async (photoId, quantity = 1) => {
  try {
    // Get current cart
    const cartData = await AsyncStorage.getItem(CART_STORAGE_KEY);
    const cart = cartData ? JSON.parse(cartData) : [];
    
    // Check if item already exists in cart
    const existingItemIndex = cart.findIndex(item => item.id === photoId);
    
    if (existingItemIndex >= 0) {
      // Update quantity if item exists
      cart[existingItemIndex].quantity += quantity;
    } else {
      // Add new item if it doesn't exist
      cart.push({ id: photoId, quantity });
    }
    
    // Save updated cart
    await AsyncStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart));
    
    return cart;
  } catch (error) {
    console.error('Error adding item to cart:', error);
    throw error;
  }
};

// Update item quantity in cart
export const updateCartItemQuantity = async (photoId, quantity) => {
  try {
    // Get current cart
    const cartData = await AsyncStorage.getItem(CART_STORAGE_KEY);
    const cart = cartData ? JSON.parse(cartData) : [];
    
    // Find the item
    const existingItemIndex = cart.findIndex(item => item.id === photoId);
    
    if (existingItemIndex >= 0) {
      // Update quantity
      cart[existingItemIndex].quantity = quantity;
      
      // Save updated cart
      await AsyncStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart));
    }
    
    return cart;
  } catch (error) {
    console.error('Error updating cart item quantity:', error);
    throw error;
  }
};

// Remove item from cart
export const removeFromCart = async (photoId) => {
  try {
    // Get current cart
    const cartData = await AsyncStorage.getItem(CART_STORAGE_KEY);
    const cart = cartData ? JSON.parse(cartData) : [];
    
    // Filter out the item to remove
    const updatedCart = cart.filter(item => item.id !== photoId);
    
    // Save updated cart
    await AsyncStorage.setItem(CART_STORAGE_KEY, JSON.stringify(updatedCart));
    
    return updatedCart;
  } catch (error) {
    console.error('Error removing item from cart:', error);
    throw error;
  }
};

// Clear entire cart
export const clearCart = async () => {
  try {
    await AsyncStorage.removeItem(CART_STORAGE_KEY);
    return [];
  } catch (error) {
    console.error('Error clearing cart:', error);
    throw error;
  }
};

// Get cart count (number of items)
export const getCartCount = async () => {
  try {
    const cartData = await AsyncStorage.getItem(CART_STORAGE_KEY);
    const cart = cartData ? JSON.parse(cartData) : [];
    
    return cart.reduce((total, item) => total + item.quantity, 0);
  } catch (error) {
    console.error('Error getting cart count:', error);
    return 0;
  }
};

===== ./src/services/catalogService.ts =====
// src/services/catalogService.ts
import { supabase } from "@/integrations/supabase/client";
import { getCachedApiData, cacheApiData } from "@/utils/imageCache";
import { Database } from "@/types/supabase";
import { clearCatalogCache } from '@/context/FilterContext';

// Define the types for the catalog data
export interface CatalogPhoto {
  image_no: string;
  category: string | null;
  date_taken: string | null;
  circa: boolean | null;
  imprecise_date: boolean | null;
  description: string | null;
  gauge: string | null;
  thumbnail_url: string;
  image_url?: string;
  id?: string;  // Added for compatibility with other parts of the app
  country: string | null;
  organisation: string | null;
  organisation_type: string | null;
  location: string | null;
  route: string | null;
  collection: string | null;
  photographer: string | null;
  prints_allowed: boolean | null;
  internet_use: boolean | null;
  publications_use: boolean | null;
  builders: any[] | null;
  file_type: string | null;
  width: number | null;
  height: number | null;
  resolution: number | null;
  colour_space: string | null;
  colour_mode: string | null;
  cd_no: string | null;
  cd_no_hr: string | null;
  bw_image_no: string | null;
  bw_cd_no: string | null;
  active_area: string | null;
  corporate_body: string | null;
  facility: string | null;
  last_updated: string | null;
}

export interface PhotoFetchOptions {
  page?: number;
  limit?: number;
  useCache?: boolean;
  cacheDuration?: number; // minutes
  forceFresh?: boolean;  // Added to explicitly bypass cache
}

const DEFAULT_OPTIONS: PhotoFetchOptions = {
  page: 1,
  limit: 10,
  useCache: true,
  cacheDuration: 60 // 1 hour
};

/**
 * Generate Supabase storage URL for an image
 */
export const getImageUrl = (imageNo: string): string => {
  // Normalize the image_no by removing spaces to match the file name format
  const normalizedImageNo = imageNo.replace(/\s/g, ''); // e.g., "Class 1800 (10)" -> "Class1800(10)"
  const url = supabase.storage.from('picaloco').getPublicUrl(`images/${normalizedImageNo}.webp`).data.publicUrl;
  return url;
};

/**
 * Fetch catalog photos with pagination and caching
 */
export const fetchCatalogPhotos = async (
  page: number = 1, 
  limit: number = 10,
  options?: Partial<Omit<PhotoFetchOptions, 'page' | 'limit'>>
): Promise<CatalogPhoto[]> => {
  const { useCache, cacheDuration, forceFresh } = { ...DEFAULT_OPTIONS, ...options, page, limit };
  
  try {
    const cacheKey = `photos_page_${page}_limit_${limit}`;
    
    // Try to get from cache first if enabled AND not forced fresh
    if (useCache && !forceFresh) {
      const cachedData = await getCachedApiData(cacheKey);
      if (cachedData) {
        console.log('Using cached catalog photos for page:', page);
        return cachedData;
      }
    } else if (forceFresh) {
      console.log('Bypassing cache for catalog photos, getting fresh data');
    }
    
    // If not in cache or forced fresh, fetch from API
    const offset = (page - 1) * limit;
    
    const { data, error } = await supabase
      .from('mobile_catalog_view')
      .select('*')
      .order('date_taken', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw error;
    if (!data || data.length === 0) {
      console.warn('No photos found');
      return [];
    }

    // Add image URLs and normalize the data
    const photosWithUrls = data.map(photo => ({
      ...photo,
      id: photo.image_no, // Ensure id is set for compatibility
      image_url: getImageUrl(photo.image_no)
    }));
    
    // Cache the result if enabled and not forced fresh
    if (useCache && !forceFresh && photosWithUrls.length > 0) {
      await cacheApiData(cacheKey, photosWithUrls, cacheDuration);
    }

    return photosWithUrls;
  } catch (error) {
    console.error('Error in fetchCatalogPhotos:', error);
    throw error;
  }
};


/**
 * Fetch photos by category with pagination and caching
 */
export const fetchPhotosByCategory = async (
  category: string, 
  page: number = 1, 
  limit: number = 10,
  options?: Partial<Omit<PhotoFetchOptions, 'page' | 'limit'>>
): Promise<CatalogPhoto[]> => {
  const { useCache, cacheDuration } = { ...DEFAULT_OPTIONS, ...options, page, limit };
  
  if (!category) {
    throw new Error('Category is required');
  }

  try {
    const cacheKey = `category_${category.toLowerCase()}_page_${page}_limit_${limit}`;
    
    // Try to get from cache first if enabled
    if (useCache) {
      const cachedData = await getCachedApiData(cacheKey);
      if (cachedData) {
        console.log('Using cached category photos for:', category, 'page:', page);
        return cachedData;
      }
    }
    
    // If not in cache, fetch from API
    const offset = (page - 1) * limit;
    const { data, error } = await supabase
      .from('mobile_catalog_view')
      .select('*')
      .eq('category', category)
      .order('date_taken', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw error;
    if (!data || data.length === 0) {
      console.warn(`No photos found for category: ${category}`);
      return [];
    }

    // Add image URLs and normalize the data
    const photosWithUrls = data.map(photo => ({
      ...photo,
      id: photo.image_no, // Ensure id is set for compatibility
      image_url: getImageUrl(photo.image_no)
    }));
    
    // Cache the result if enabled
    if (useCache && photosWithUrls.length > 0) {
      await cacheApiData(cacheKey, photosWithUrls, cacheDuration);
    }

    return photosWithUrls;
  } catch (error) {
    console.error('Error in fetchPhotosByCategory:', error);
    throw error;
  }
};

/**
 * Fetch a single photo by its ID (image_no)
 */
export const fetchPhotoById = async (
  imageNo: string, 
  options?: Partial<Omit<PhotoFetchOptions, 'page' | 'limit'>>
): Promise<CatalogPhoto | null> => {
  const { useCache, cacheDuration } = { ...DEFAULT_OPTIONS, ...options };
  
  if (!imageNo) {
    throw new Error('Image number is required');
  }

  try {
    const cacheKey = `photo_${imageNo}`;
    
    // Try to get from cache first if enabled
    if (useCache) {
      const cachedData = await getCachedApiData(cacheKey);
      if (cachedData) {
        console.log('Using cached photo data for:', imageNo);
        return cachedData;
      }
    }
    
    // If not in cache, fetch from API
    const { data, error } = await supabase
      .from('mobile_catalog_view')
      .select('*')
      .eq('image_no', imageNo)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching photo by ID:', error);
      throw error;
    }
    
    if (!data) {
      return null;
    }

    // Add image URL
    const photoWithUrl = {
      ...data,
      id: data.image_no, // Ensure id is set for compatibility
      image_url: getImageUrl(data.image_no)
    };
    
    // Cache the result if enabled
    if (useCache) {
      await cacheApiData(cacheKey, photoWithUrl, cacheDuration || 180); // Cache individual photos longer (3 hours)
    }
    
    return photoWithUrl;
  } catch (error) {
    console.error('Error in fetchPhotoById:', error);
    throw error;
  }
};

/**
 * Fetch unique categories
 */
export const fetchCategories = async (
  options?: Partial<Omit<PhotoFetchOptions, 'page' | 'limit'>>
): Promise<string[]> => {
  const { useCache, cacheDuration, forceFresh } = { ...DEFAULT_OPTIONS, ...options };
  
  try {
    const cacheKey = 'categories_list';
    
    // Try to get from cache first if enabled AND not forced fresh
    if (useCache && !forceFresh) {
      const cachedData = await getCachedApiData(cacheKey);
      if (cachedData) {
        console.log('Using cached categories data');
        return cachedData;
      }
    } else if (forceFresh) {
      console.log('Bypassing cache for categories, getting fresh data');
    }
  
    
    const { data, error } = await supabase
      .from('mobile_catalog_view')
      .select('category')
      .not('category', 'is', null);
    
    if (error) {
      console.error('Error fetching categories:', error);
      throw error;
    }
    
    // Extract unique categories
    const categories = data
      .map(item => item.category)
      .filter((value, index, self) => 
        value && self.indexOf(value) === index
      ) as string[];
    
    // Sort alphabetically
    categories.sort();
    
    // Cache the result if enabled and not forced fresh
    if (useCache && !forceFresh) {
      await cacheApiData(cacheKey, categories, cacheDuration || 1440); // Cache categories for 1 day
    }
    
    return categories;
  } catch (error) {
    console.error('Error in fetchCategories:', error);
    throw error;
  }
};

/**
 * Search photos by query term
 */
export const searchPhotos = async (
  searchQuery: string,
  page: number = 1,
  limit: number = 10,
  options?: Partial<Omit<PhotoFetchOptions, 'page' | 'limit'>>
): Promise<CatalogPhoto[]> => {
  const { useCache, cacheDuration } = { ...DEFAULT_OPTIONS, ...options, page, limit };
  
  try {
    // If search query is empty, return regular catalog photos
    if (!searchQuery.trim()) {
      return await fetchCatalogPhotos(page, limit, { useCache, cacheDuration });
    }
    
    const query = searchQuery.toLowerCase().trim();
    const cacheKey = `search_${query}_page_${page}_limit_${limit}`;
    
    // Try to get from cache first if enabled
    if (useCache) {
      const cachedResults = await getCachedApiData(cacheKey);
      if (cachedResults) {
        console.log('Using cached search results for:', searchQuery, 'page:', page);
        return cachedResults;
      }
    }
    
    // Not in cache, perform the search
    const offset = (page - 1) * limit;
    
    const { data, error } = await supabase
      .from('mobile_catalog_view')
      .select('*')
      .or(`description.ilike.%${query}%,category.ilike.%${query}%,photographer.ilike.%${query}%,location.ilike.%${query}%`)
      .order('date_taken', { ascending: false })
      .range(offset, offset + limit - 1);
    
    if (error) {
      console.error('Supabase search error:', error);
      throw error;
    }
    
    console.log(`Search returned ${data?.length || 0} results`);
    
    if (!data || data.length === 0) {
      return [];
    }
    
    // Add image URLs and normalize the data
    const photosWithUrls = data.map(photo => ({
      ...photo,
      id: photo.image_no, // Ensure id is set for compatibility
      image_url: getImageUrl(photo.image_no)
    }));
    
    // Cache the search results if enabled
    if (useCache && photosWithUrls.length > 0) {
      await cacheApiData(cacheKey, photosWithUrls, cacheDuration || 15); // Cache search results for 15 minutes
    }
    
    return photosWithUrls;
  } catch (error) {
    console.error('Error in searchPhotos:', error);
    throw error;
  }
};

// Add photoService filter helpers for compatibility
export interface PhotoFilters {
  tags: string[];
  photographers: string[];
  locations: string[];
  priceRange: [number, number];
  orientation?: 'landscape' | 'portrait' | undefined;
  sortBy: 'newest' | 'popular' | 'price_high' | 'price_low';
}

/**
 * Check if filters are active
 */
export const hasActiveFilters = (
  filters: PhotoFilters, 
  defaultMinPrice: number, 
  defaultMaxPrice: number
): boolean => {
  const { tags, photographers, locations, priceRange } = filters;
  
  return (
    tags.length > 0 || 
    photographers.length > 0 || 
    locations.length > 0 || 
    priceRange[0] > defaultMinPrice || 
    priceRange[1] < defaultMaxPrice
  );
};

/**
 * Count active filters
 */
export const countActiveFilters = (
  filters: PhotoFilters, 
  defaultMinPrice: number, 
  defaultMaxPrice: number
): number => {
  const { tags, photographers, locations, priceRange } = filters;
  
  let count = 0;
  if (tags.length > 0) count += 1;
  if (photographers.length > 0) count += 1;
  if (locations.length > 0) count += 1;
  if (priceRange[0] > defaultMinPrice || priceRange[1] < defaultMaxPrice) count += 1;
  
  return count;
};

// Bypass cache for filtered queries
export const fetchFilteredPhotos = async (
  filters: any, // Your filter object structure
  options: PhotoFetchOptions = DEFAULT_OPTIONS
): Promise<CatalogPhoto[]> => {
  console.log('Executing filtered query with fresh data');
  
  try {
    // Build the base query
    let query = supabase
      .from('mobile_catalog_view')
      .select('*');
      
    // Apply your filters here...
    // ...
    
    const { data, error } = await query
      .order('date_taken', { ascending: false })
      .limit(options.limit || 50);
      
    if (error) throw error;
    
    // Process data and return
    const photosWithUrls = (data || []).map(photo => ({
      ...photo,
      id: photo.image_no,
      image_url: getImageUrl(photo.image_no)
    }));
    
    return photosWithUrls;
  } catch (error) {
    console.error('Error in fetchFilteredPhotos:', error);
    throw error;
  }
};


/**
 * Filter photos based on criteria
 * (Compatible with both Photo and CatalogPhoto types)
 */
export const filterPhotos = (photos: CatalogPhoto[], filters: PhotoFilters): CatalogPhoto[] => {
  const { tags, photographers, locations, priceRange, sortBy } = filters;
  
  // Filter photos
  let filtered = [...photos];
  
  // Handle tags (this is different between Photo and CatalogPhoto)
  if (tags.length > 0) {
    filtered = filtered.filter(photo => {
      // For CatalogPhoto, use category
      if (photo.category && tags.includes(photo.category)) {
        return true;
      }
      
      // For objects with tags array (like from photoService)
      if ('tags' in photo && Array.isArray(photo.tags)) {
        return tags.some(tag => photo.tags.includes(tag));
      }
      
      return false;
    });
  }
  
  // Filter by photographer
  if (photographers.length > 0) {
    filtered = filtered.filter(photo => 
      photo.photographer && photographers.includes(photo.photographer)
    );
  }
  
  // Filter by location
  if (locations.length > 0) {
    filtered = filtered.filter(photo => 
      photo.location && locations.includes(photo.location)
    );
  }
  
  // Price filtering is skipped for CatalogPhoto as it doesn't have price field
  
  // Sort photos based on available properties
  if (sortBy) {
    switch (sortBy) {
      case 'newest':
        filtered.sort((a, b) => {
          const dateA = a.date_taken ? new Date(a.date_taken).getTime() : 0;
          const dateB = b.date_taken ? new Date(b.date_taken).getTime() : 0;
          return dateB - dateA;
        });
        break;
      case 'popular':
        // If we had a popularity metric, we'd use it here
        break;
      case 'price_high':
      case 'price_low':
        // Price sorting skipped for CatalogPhoto as it doesn't have price field
        break;
    }
  }
  
  return filtered;
};
===== ./src/services/photoService.ts =====
// Photo data model
export interface Photo {
  id: string;
  title: string;
  description: string;
  imageUrl: string;
  thumbnailUrl: string;
  price: number;
  photographer: string;
  location: string;
  dateTaken: string;
  camera: string;
  resolution: string;
  tags: string[];
  popularity: number;
}

// Sample data for the app
export const allPhotos: Photo[] = [
  {
    id: 'photo1',
    title: 'Steam Locomotive at Sunset',
    description: 'A vintage steam locomotive traveling through a mountain pass at sunset.',
    imageUrl: 'https://images.unsplash.com/photo-1527084010126-2a48931d701e?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1920&q=80',
    thumbnailUrl: 'https://images.unsplash.com/photo-1527084010126-2a48931d701e?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80',
    price: 49.99,
    photographer: 'Thomas Rails',
    location: 'Rocky Mountains, Colorado',
    dateTaken: '2022-06-15',
    camera: 'Canon EOS 5D Mark IV',
    resolution: '5760 x 3840',
    tags: ['steam', 'sunset', 'mountains'],
    popularity: 94
  },
  {
    id: 'photo2',
    title: 'Modern High-Speed Train',
    description: 'A sleek high-speed passenger train zooming through a rural landscape.',
    imageUrl: 'https://images.unsplash.com/photo-1474487548417-781cb71495f3?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1920&q=80',
    thumbnailUrl: 'https://images.unsplash.com/photo-1474487548417-781cb71495f3?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80',
    price: 39.99,
    photographer: 'Emma Tracks',
    location: 'Countryside, Japan',
    dateTaken: '2023-01-22',
    camera: 'Sony Alpha A7 III',
    resolution: '6000 x 4000',
    tags: ['modern', 'high-speed', 'rural'],
    popularity: 88
  },
  {
    id: 'photo3',
    title: 'Historic Railway Station',
    description: 'Interior view of a grand 19th century railway station with ornate architecture.',
    imageUrl: 'https://images.unsplash.com/photo-1530793740-c7d0855c949a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1920&q=80',
    thumbnailUrl: 'https://images.unsplash.com/photo-1530793740-c7d0855c949a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80',
    price: 54.99,
    photographer: 'Michael Stations',
    location: 'Grand Central, New York',
    dateTaken: '2021-11-05',
    camera: 'Nikon D850',
    resolution: '8256 x 5504',
    tags: ['stations', 'historic', 'architecture'],
    popularity: 92
  },
  {
    id: 'photo4',
    title: 'Mountain Railway Journey',
    description: 'A scenic railway winding through alpine mountains covered with snow.',
    imageUrl: 'https://images.unsplash.com/photo-1480796927426-f609979314bd?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1920&q=80',
    thumbnailUrl: 'https://images.unsplash.com/photo-1480796927426-f609979314bd?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80',
    price: 59.99,
    photographer: 'Sarah Alpine',
    location: 'Swiss Alps, Switzerland',
    dateTaken: '2022-02-18',
    camera: 'Canon EOS R5',
    resolution: '8192 x 5464',
    tags: ['scenic', 'mountains', 'snow'],
    popularity: 96
  },
  {
    id: 'photo5',
    title: 'Night Train Departure',
    description: 'A passenger train illuminated at night, ready for departure from the platform.',
    imageUrl: 'https://images.unsplash.com/photo-1474302694023-9711af8045cf?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1920&q=80',
    thumbnailUrl: 'https://images.unsplash.com/photo-1474302694023-9711af8045cf?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80',
    price: 44.99,
    photographer: 'James Nightrail',
    location: 'Berlin Central Station, Germany',
    dateTaken: '2023-03-30',
    camera: 'Sony Alpha A9 II',
    resolution: '6000 x 4000',
    tags: ['modern', 'night', 'stations'],
    popularity: 86
  }
];

// Service functions
export const getAllPhotos = async (): Promise<Photo[]> => {
  // Simulating API call with a delay
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(allPhotos);
    }, 500);
  });
};

export const getPhotoById = (id: string): Photo | undefined => {
  return allPhotos.find(photo => photo.id === id);
};

export const getPhotosByCategory = (category: string): Photo[] => {
  if (category === 'all') return allPhotos;
  return allPhotos.filter(photo => photo.tags.includes(category));
};

// Extract metadata for filters
export const extractMetadata = () => {
  const tags = Array.from(new Set(allPhotos.flatMap(photo => photo.tags)));
  const photographers = Array.from(new Set(allPhotos.map(photo => photo.photographer)));
  const locations = Array.from(new Set(allPhotos.map(photo => photo.location)));
  const prices = allPhotos.map(photo => photo.price);
  const minPrice = Math.min(...prices);
  const maxPrice = Math.max(...prices);
  
  return { tags, photographers, locations, minPrice, maxPrice };
};

// Filter helper functions
export interface PhotoFilters {
  tags: string[];
  photographers: string[];
  locations: string[];
  priceRange: [number, number];
  orientation?: 'landscape' | 'portrait' | undefined;
  sortBy: 'newest' | 'popular' | 'price_high' | 'price_low';
}

export const hasActiveFilters = (
  filters: PhotoFilters, 
  defaultMinPrice: number, 
  defaultMaxPrice: number
): boolean => {
  const { tags, photographers, locations, priceRange } = filters;
  
  return (
    tags.length > 0 || 
    photographers.length > 0 || 
    locations.length > 0 || 
    priceRange[0] > defaultMinPrice || 
    priceRange[1] < defaultMaxPrice
  );
};

export const countActiveFilters = (
  filters: PhotoFilters, 
  defaultMinPrice: number, 
  defaultMaxPrice: number
): number => {
  const { tags, photographers, locations, priceRange } = filters;
  
  let count = 0;
  if (tags.length > 0) count += 1;
  if (photographers.length > 0) count += 1;
  if (locations.length > 0) count += 1;
  if (priceRange[0] > defaultMinPrice || priceRange[1] < defaultMaxPrice) count += 1;
  
  return count;
};

export const filterPhotos = (photos: Photo[], filters: PhotoFilters): Photo[] => {
  const { tags, photographers, locations, priceRange, sortBy } = filters;
  
  // Filter photos
  let filtered = [...photos];
  
  if (tags.length > 0) {
    filtered = filtered.filter(photo => 
      tags.some(tag => photo.tags.includes(tag))
    );
  }
  
  if (photographers.length > 0) {
    filtered = filtered.filter(photo => 
      photographers.includes(photo.photographer)
    );
  }
  
  if (locations.length > 0) {
    filtered = filtered.filter(photo => 
      locations.includes(photo.location)
    );
  }
  
  filtered = filtered.filter(photo => 
    photo.price >= priceRange[0] && photo.price <= priceRange[1]
  );
  
  // Sort photos
  switch (sortBy) {
    case 'newest':
      filtered.sort((a, b) => new Date(b.dateTaken).getTime() - new Date(a.dateTaken).getTime());
      break;
    case 'popular':
      filtered.sort((a, b) => b.popularity - a.popularity);
      break;
    case 'price_high':
      filtered.sort((a, b) => b.price - a.price);
      break;
    case 'price_low':
      filtered.sort((a, b) => a.price - b.price);
      break;
  }
  
  return filtered;
};

===== ./src/services/supabase.ts =====
import { createClient } from '@supabase/supabase-js';

// Option 1: Using process.env with dotenv
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;

// Option 2: Using expo-constants (if you're using Expo's config system)
// import Constants from 'expo-constants';
// const supabaseUrl = Constants.expoConfig?.extra?.supabaseUrl;
// const supabaseAnonKey = Constants.expoConfig?.extra?.supabaseAnonKey;

// Validate environment variables
if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Supabase URL and anon key must be provided in the .env file');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
===== ./src/services/userService.js =====

import AsyncStorage from '@react-native-async-storage/async-storage';

// Get user profile
export const getUserProfile = async () => {
  try {
    // In a real app, you would fetch this from an API based on the authenticated user
    // For now, we'll use a mock profile
    
    // Get sample order history
    const orders = [
      { id: "ORD-1234", date: "2023-05-15", total: 129.97, status: "Completed" },
      { id: "ORD-2345", date: "2023-06-22", total: 79.99, status: "Processing" }
    ];
    
    // Get sample favorites
    const favorites = await getFavorites();
    
    // Get token and check if user is admin
    const userToken = await AsyncStorage.getItem('userToken');
    const userRole = await AsyncStorage.getItem('userRole');
    
    if (!userToken) {
      throw new Error('Not authenticated');
    }
    
    return {
      name: "John Doe",
      email: "john.doe@example.com",
      avatar: "https://randomuser.me/api/portraits/men/32.jpg",
      isAdmin: userRole === 'admin',
      memberSince: "January 2023",
      orders,
      favorites
    };
  } catch (error) {
    console.error('Error getting user profile:', error);
    throw error;
  }
};

// Get user favorites
export const getFavorites = async () => {
  try {
    const favoritesJson = await AsyncStorage.getItem('favorites');
    return favoritesJson ? JSON.parse(favoritesJson) : [];
  } catch (error) {
    console.error('Error getting favorites:', error);
    return [];
  }
};

// Add to favorites
export const addToFavorites = async (photoId) => {
  try {
    const favoritesJson = await AsyncStorage.getItem('favorites');
    const favorites = favoritesJson ? JSON.parse(favoritesJson) : [];
    
    if (!favorites.includes(photoId)) {
      const updatedFavorites = [...favorites, photoId];
      await AsyncStorage.setItem('favorites', JSON.stringify(updatedFavorites));
    }
    
    return { success: true };
  } catch (error) {
    console.error('Error adding to favorites:', error);
    throw error;
  }
};

// Remove from favorites
export const removeFromFavorites = async (photoId) => {
  try {
    const favoritesJson = await AsyncStorage.getItem('favorites');
    const favorites = favoritesJson ? JSON.parse(favoritesJson) : [];
    
    const updatedFavorites = favorites.filter(id => id !== photoId);
    await AsyncStorage.setItem('favorites', JSON.stringify(updatedFavorites));
    
    return { success: true };
  } catch (error) {
    console.error('Error removing from favorites:', error);
    throw error;
  }
};

// Get all users (for admin)
export const getAllUsers = async () => {
  try {
    // Check if user is admin
    const userRole = await AsyncStorage.getItem('userRole');
    
    if (userRole !== 'admin') {
      throw new Error('Unauthorized');
    }
    
    // Get users from storage
    const usersJson = await AsyncStorage.getItem('users');
    const users = usersJson ? JSON.parse(usersJson) : [];
    
    // Return sanitized user data (without passwords)
    return users.map(user => ({
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role
    }));
  } catch (error) {
    console.error('Error getting all users:', error);
    throw error;
  }
};

===== ./src/types/supabase.ts =====
export type Database = {
  public: {
    Tables: {
      mobile_catalog_view: {
        Row: {
          image_no: string;
          category: string | null;
          date_taken: string | null;
          circa: boolean | null;
          imprecise_date: boolean | null;
          description: string | null;
          gauge: string | null;
          thumbnail_url: string;
          country: string | null;
          organisation: string | null;
          organisation_type: string | null;
          location: string | null;
          route: string | null;
          collection: string | null;
          photographer: string | null;
          prints_allowed: boolean | null;
          internet_use: boolean | null;
          publications_use: boolean | null;
          builders: any[] | null;
          file_type: string | null;
          width: number | null;
          height: number | null;
          resolution: number | null;
          colour_space: string | null;
          colour_mode: string | null;
          cd_no: string | null;
          cd_no_hr: string | null;
          bw_image_no: string | null;
          bw_cd_no: string | null;
          active_area: string | null;
          corporate_body: string | null;
          facility: string | null;
          last_updated: string | null;
        };
        Insert: never;
        Update: never;
      };
    };
    Views: {
      mobile_catalog_view: {
        Row: Database['public']['Tables']['mobile_catalog_view']['Row'];
        Insert: never;
        Update: never;
      };
    };
  };
}; 

===== ./src/utils/animations.tsx =====

import { Animated } from 'react-native';
import React, { useState, useEffect, useRef } from 'react';

// Function to create a fade-in animation
export const fadeInAnimation = (animatedValue: Animated.Value, duration = 500) => {
  Animated.timing(animatedValue, {
    toValue: 1,
    duration,
    useNativeDriver: true,
  }).start();
};

// Function to create a slide-in animation
export const slideInAnimation = (
  animatedValue: Animated.Value, 
  from: number, 
  to: number, 
  duration = 500
) => {
  Animated.timing(animatedValue, {
    toValue: to,
    duration,
    useNativeDriver: true,
  }).start();
};

// Function to create a spring animation
export const springAnimation = (
  animatedValue: Animated.Value, 
  toValue: number, 
  friction = 7, 
  tension = 40
) => {
  Animated.spring(animatedValue, {
    toValue,
    friction,
    tension,
    useNativeDriver: true,
  }).start();
};

// Function to create a sequence of animations
export const sequenceAnimations = (animations: Animated.CompositeAnimation[]) => {
  Animated.sequence(animations).start();
};

// Function to create a stagger animation for a list of items
export const staggerAnimations = (
  animatedValues: Animated.Value[], 
  toValue: number, 
  duration = 300, 
  delay = 50
) => {
  const animations = animatedValues.map((value) =>
    Animated.timing(value, {
      toValue,
      duration,
      useNativeDriver: true,
    })
  );
  
  Animated.stagger(delay, animations).start();
};

// Export animated number format function (for numeric displays)
export const formatNumber = (value: number, decimals = 0) => {
  return value.toFixed(decimals);
};

// Add AnimatedNumber component
interface AnimatedNumberProps {
  value: number;
  formatValue?: (value: number) => string;
  duration?: number;
}

export const AnimatedNumber: React.FC<AnimatedNumberProps> = ({ 
  value, 
  formatValue = (val) => val.toString(), 
  duration = 500 
}) => {
  const [displayValue, setDisplayValue] = useState(value);
  const prevValue = useRef(value);

  useEffect(() => {
    const start = prevValue.current;
    const end = value;
    const startTime = Date.now();
    
    const animateValue = () => {
      const now = Date.now();
      const elapsed = now - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      const currentValue = start + (end - start) * progress;
      setDisplayValue(currentValue);
      
      if (progress < 1) {
        requestAnimationFrame(animateValue);
      } else {
        prevValue.current = end;
      }
    };
    
    requestAnimationFrame(animateValue);
  }, [value, duration]);
  
  return <>{formatValue(displayValue)}</>;
};

// Add StaggerChildren component
interface StaggerChildrenProps {
  children: React.ReactNode;
  staggerMs?: number;
  delayMs?: number;
}

export const StaggerChildren: React.FC<StaggerChildrenProps> = ({ 
  children, 
  staggerMs = 50, 
  delayMs = 0 
}) => {
  const childrenArray = React.Children.toArray(children);
  
  return (
    <>
      {React.Children.map(children, (child, index) => {
        if (!React.isValidElement(child)) return child;
        
        return React.cloneElement(child, {
          ...child.props,
          style: {
            ...child.props.style,
            animationDelay: `${delayMs + (index * staggerMs)}ms`,
            animationFillMode: 'both',
            animationName: 'fade-in',
            animationDuration: '300ms'
          },
          className: `animate-fade-in ${child.props.className || ''}`
        });
      })}
    </>
  );
};

===== ./src/utils/cache.ts =====
// src/utils/cache.ts
import AsyncStorage from '@react-native-async-storage/async-storage';

// Cache photo data with expiry
export const cachePhotoData = async (key: string, data: any, expiryMinutes = 60) => {
  try {
    const item = {
      data,
      expiry: Date.now() + (expiryMinutes * 60 * 1000)
    };
    await AsyncStorage.setItem(key, JSON.stringify(item));
  } catch (error) {
    console.error('Error caching data:', error);
  }
};

// Get cached photo data if not expired
export const getCachedPhotoData = async (key: string) => {
  try {
    const json = await AsyncStorage.getItem(key);
    if (!json) return null;
    
    const item = JSON.parse(json);
    if (Date.now() > item.expiry) {
      await AsyncStorage.removeItem(key);
      return null;
    }
    
    return item.data;
  } catch (error) {
    console.error('Error retrieving cached data:', error);
    return null;
  }
};
===== ./src/utils/imageCache.ts =====
// src/utils/imageCache.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Image } from 'react-native';
import { getCachedPhotoData, cachePhotoData } from './cache'; // Import existing cache functions for compatibility

// Constants
const CACHE_PREFIX = 'app_cache_';
const DEFAULT_EXPIRY_MINUTES = 60; // 1 hour

/**
 * Cache interface for stored items
 */
interface CacheItem<T> {
  data: T;
  expiry: number; // timestamp
}

/**
 * Pre-load and cache images
 */
export const prefetchImage = async (uri: string): Promise<boolean> => {
  try {
    await Image.prefetch(uri);
    // Mark this URL as prefetched
    await AsyncStorage.setItem(`${CACHE_PREFIX}img_prefetched_${uri}`, 'true');
    return true;
  } catch (error) {
    console.error('Error prefetching image:', error);
    return false;
  }
};

/**
 * Check if an image has been prefetched
 */
export const isImagePrefetched = async (uri: string): Promise<boolean> => {
  try {
    const value = await AsyncStorage.getItem(`${CACHE_PREFIX}img_prefetched_${uri}`);
    return value === 'true';
  } catch (error) {
    console.error('Error checking if image is prefetched:', error);
    return false;
  }
};

/**
 * Cache API data with expiry
 */
export const cacheApiData = async <T>(
  key: string, 
  data: T, 
  expiryMinutes: number = DEFAULT_EXPIRY_MINUTES
): Promise<void> => {
  try {
    // Forward to existing cache function if possible for backward compatibility
    if (typeof cachePhotoData === 'function') {
      await cachePhotoData(key, data, expiryMinutes);
      return;
    }
    
    // Fall back to direct implementation
    const item: CacheItem<T> = {
      data,
      expiry: Date.now() + (expiryMinutes * 60 * 1000)
    };
    await AsyncStorage.setItem(`${CACHE_PREFIX}${key}`, JSON.stringify(item));
  } catch (error) {
    console.error('Error caching API data:', error);
  }
};

/**
 * Get cached API data if not expired
 */
export const getCachedApiData = async <T>(key: string): Promise<T | null> => {
  try {
    // Forward to existing cache function if possible for backward compatibility
    if (typeof getCachedPhotoData === 'function') {
      return getCachedPhotoData(key) as Promise<T | null>;
    }
    
    // Fall back to direct implementation
    const cacheKey = `${CACHE_PREFIX}${key}`;
    const json = await AsyncStorage.getItem(cacheKey);
    
    if (!json) return null;
    
    const item = JSON.parse(json) as CacheItem<T>;
    
    if (Date.now() > item.expiry) {
      // Cache expired
      await AsyncStorage.removeItem(cacheKey);
      return null;
    }
    
    return item.data;
  } catch (error) {
    console.error('Error retrieving cached data:', error);
    return null;
  }
};

/**
 * Remove a specific item from the cache
 */
export const removeCachedItem = async (key: string): Promise<void> => {
  try {
    await AsyncStorage.removeItem(`${CACHE_PREFIX}${key}`);
  } catch (error) {
    console.error('Error removing cached item:', error);
  }
};

/**
 * Clear all cached data
 */
export const clearCache = async (): Promise<void> => {
  try {
    const keys = await AsyncStorage.getAllKeys();
    const cacheKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));
    await AsyncStorage.multiRemove(cacheKeys);
  } catch (error) {
    console.error('Error clearing cache:', error);
  }
};

/**
 * Clear expired cache items
 */
export const clearExpiredCache = async (): Promise<number> => {
  try {
    const keys = await AsyncStorage.getAllKeys();
    const cacheKeys = keys.filter(key => key.startsWith(CACHE_PREFIX) && !key.includes('img_prefetched_'));
    let clearedCount = 0;
    
    // Check each key and remove if expired
    await Promise.all(
      cacheKeys.map(async (key) => {
        const json = await AsyncStorage.getItem(key);
        if (!json) return;
        
        const item = JSON.parse(json) as CacheItem<any>;
        if (Date.now() > item.expiry) {
          await AsyncStorage.removeItem(key);
          clearedCount++;
        }
      })
    );
    
    return clearedCount;
  } catch (error) {
    console.error('Error clearing expired cache:', error);
    return 0;
  }
};
===== ./supabase/config.toml =====
project_id = "tvucfqzldbcghtxddtmq"
===== ./tailwind.config.js =====

module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}", "./App.js"],
  theme: {
    extend: {
      colors: {
        primary: '#1A237E', // Dark Blue
        secondary: '#D32F2F', // Red for navbar
        background: '#FFFFFF', // White background
        border: '#e5e7eb',
        foreground: '#1f2937',
      },
    },
  },
  plugins: [],
};

===== ./tailwind.config.ts =====

import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				}
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: { height: '0' },
					to: { height: 'var(--radix-accordion-content-height)' }
				},
				'accordion-up': {
					from: { height: 'var(--radix-accordion-content-height)' },
					to: { height: '0' }
				},
				'fade-in': {
					from: { opacity: '0' },
					to: { opacity: '1' }
				},
				'fade-out': {
					from: { opacity: '1' },
					to: { opacity: '0' }
				},
				'slide-up': {
					from: { transform: 'translateY(10px)', opacity: '0' },
					to: { transform: 'translateY(0)', opacity: '1' }
				},
				'slide-down': {
					from: { transform: 'translateY(-10px)', opacity: '0' },
					to: { transform: 'translateY(0)', opacity: '1' }
				},
				'scale-in': {
					from: { transform: 'scale(0.95)', opacity: '0' },
					to: { transform: 'scale(1)', opacity: '1' }
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out',
				'fade-in': 'fade-in 0.5s ease-out',
				'fade-out': 'fade-out 0.5s ease-out',
				'slide-up': 'slide-up 0.5s ease-out',
				'slide-down': 'slide-down 0.5s ease-out',
				'scale-in': 'scale-in 0.3s ease-out'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;

===== ./tsconfig.app.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "App.tsx"]
}

===== ./tsconfig.json =====
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.node.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  },
  "extends": "expo/tsconfig.base"
}

===== ./tsconfig.node.json =====
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  }
}

